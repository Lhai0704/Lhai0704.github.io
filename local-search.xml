<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/02/15/DeepSeek/"/>
    <url>/2025/02/15/DeepSeek/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepSeek、ChatGPT（如GPT-4o）和Claude（如Claude-3-5-Sonnet）的区别"><a href="#DeepSeek、ChatGPT（如GPT-4o）和Claude（如Claude-3-5-Sonnet）的区别" class="headerlink" title="DeepSeek、ChatGPT（如GPT-4o）和Claude（如Claude-3.5-Sonnet）的区别"></a>DeepSeek、ChatGPT（如GPT-4o）和Claude（如Claude-3.5-Sonnet）的区别</h2><ul><li>DeepSeek开源（<a href="https://huggingface.co/deepseek-ai/DeepSeek-R1）">https://huggingface.co/deepseek-ai/DeepSeek-R1）</a></li><li>训练成本低</li><li>某些问题下，解答速度快，幻觉少</li><li>API价格便宜，兼容OpenAI接口</li></ul><h1 id="RAGFlow"><a href="#RAGFlow" class="headerlink" title="RAGFlow"></a>RAGFlow</h1><p>将文件上传到RAGFlow中的知识库并将其解析为数据集。知识库实际上是数据库的集合。</p><p>RAGFlow 中的问答可以基于特定知识库或多个知识库。RAGFlow 支持的文件格式包括文档（PDF、DOC、DOCX、TXT、MD）、表格（CSV、XLSX、XLS）、图片（JPEG、JPG、PNG、TIF、GIF）和幻灯片（PPT、PPTX）。</p><p>RAGFlow 提供多种块模板chunk templates。为您的知识库选择嵌入模型和块方法（模板）。</p><p>RAGFlow 具有可见性和可解释性，可让您查看分块结果并在必要时进行干预。</p><p>双击分块文本以添加关键字或在必要时进行_手动_更改（您可以将关键字添加到文件块中，以提高其对包含这些关键字的查询的排名。此操作会增加其关键字权重，并可以提高其在搜索列表中的排名。）</p><h2 id="配置知识库"><a href="#配置知识库" class="headerlink" title="配置知识库"></a>配置知识库</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/01/31/LineByLine/"/>
    <url>/2025/01/31/LineByLine/</url>
    
    <content type="html"><![CDATA[<p>一款有逐行翻译功能的电子书阅读器软件。Electron + React</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果没有安装 Homebrew，先安装它</span><br>/bin/bash -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span><br><br><span class="hljs-comment"># 使用 Homebrew 安装 Node.js</span><br>brew install node<br><br><span class="hljs-comment"># 验证安装</span><br>node --version<br>npm --version<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建项目文件夹</span><br><span class="hljs-built_in">mkdir</span> ebook-reader<br><span class="hljs-built_in">cd</span> ebook-reader<br><br><span class="hljs-comment"># 初始化项目</span><br>npm init -y<br><br><span class="hljs-comment"># 安装必要的依赖</span><br>npm install electron@latest react@latest react-dom@latest<br>npm install --save-dev @babel/core @babel/preset-react @babel/preset-env<br>npm install --save-dev webpack webpack-cli babel-loader<br></code></pre></td></tr></table></figure><p>注：npm install electron@latest时速度慢，额外添加electron的镜像，参考<a href="https://juejin.cn/post/6855526489904349198">https://juejin.cn/post/6855526489904349198</a></p><h3 id="创建项目结构"><a href="#创建项目结构" class="headerlink" title="创建项目结构"></a>创建项目结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> src<br><span class="hljs-built_in">touch</span> main.js<br><span class="hljs-built_in">touch</span> index.html<br><span class="hljs-built_in">touch</span> webpack.config.js<br><span class="hljs-built_in">touch</span> .babelrc<br></code></pre></td></tr></table></figure><h3 id="核心文件说明"><a href="#核心文件说明" class="headerlink" title="核心文件说明"></a>核心文件说明</h3><ul><li>index.html：应用程序入口页面，定义了一个div容器<code>id=&quot;root&quot;</code>，React组件会挂载在这里。<code>script src=&quot;./dist/bundle.js&quot;</code> 说明 React 代码会被 Webpack 或其他打包工具编译为 <code>bundle.js</code>，然后在这里加载。</li><li>index.js：React应用程序入口文件。负责初始化 React 应用，并把 <code>App.js</code> 组件渲染到 <code>index.html</code> 的 <code>root</code> 容器里。通过 <code>createRoot(container).render(&lt;App /&gt;)</code> 挂载 <code>App</code> 组件。</li><li>App.js：React前端界面，主React组件</li><li>main.js：Electron主进程</li><li>webpack.config.js：打包配置文件，用于将React代码编译成浏览器可运行的代码</li><li>database.js：数据库相关代码</li></ul><p>用户选择文件 -&gt; main.js 处理文件读取<br>文本分割后通过 IPC 通信传递给前端显示</p><h2 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h2><p>webpack.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,<br>  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;electron-renderer&#x27;</span>,<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|jsx)$/</span>,<br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>        <span class="hljs-attr">use</span>: &#123;<br>          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.jsx&#x27;</span>]<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>.babelrc</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-react&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>package.json，加入</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack &amp;&amp; electron .&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;watch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --watch&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>.gitignore</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">node<span class="hljs-emphasis">_modules/</span><br><span class="hljs-emphasis">dist/</span><br><span class="hljs-emphasis">.DS_</span>Store<br></code></pre></td></tr></table></figure><h2 id="添加基础代码"><a href="#添加基础代码" class="headerlink" title="添加基础代码"></a>添加基础代码</h2><p>src/index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; createRoot &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;<br><br><span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>);<br><span class="hljs-keyword">const</span> root = <span class="hljs-title function_">createRoot</span>(container);<br>root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);<br></code></pre></td></tr></table></figure><p>src/App.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">const</span> &#123; ipcRenderer &#125; = <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [lines, setLines] = <span class="hljs-title function_">useState</span>([]);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFileSelect</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> ipcRenderer.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">&#x27;select-file&#x27;</span>);<br>    <span class="hljs-title function_">setLines</span>(content);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">padding:</span> &#x27;<span class="hljs-attr">20px</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleFileSelect&#125;</span>&gt;</span></span><br><span class="language-xml">        选择文件</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">marginTop:</span> &#x27;<span class="hljs-attr">20px</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml">        &#123;lines.map((line, index) =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">marginBottom:</span> &#x27;<span class="hljs-attr">10px</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml">            &#123;line&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        ))&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>eBook Reader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; app, <span class="hljs-title class_">BrowserWindow</span>, ipcMain, dialog &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWindow</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">const</span> win = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123;<br><span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,<br><span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,<br><span class="hljs-attr">webPreferences</span>: &#123;<br><span class="hljs-attr">nodeIntegration</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">contextIsolation</span>: <span class="hljs-literal">false</span><br>&#125;<br>&#125;);<br>  <br>win.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>);<br>&#125;<br><br>app.<span class="hljs-title function_">whenReady</span>().<span class="hljs-title function_">then</span>(createWindow);<br><br>ipcMain.<span class="hljs-title function_">handle</span>(<span class="hljs-string">&#x27;select-file&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> dialog.<span class="hljs-title function_">showOpenDialog</span>(&#123;<br><span class="hljs-attr">properties</span>: [<span class="hljs-string">&#x27;openFile&#x27;</span>],<br><span class="hljs-attr">filters</span>: [<br>&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Text Files&#x27;</span>, <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;txt&#x27;</span>] &#125;<br>]<br>&#125;);<br><br><span class="hljs-keyword">if</span> (!result.<span class="hljs-property">canceled</span>) &#123;<br><span class="hljs-keyword">const</span> filePath = result.<span class="hljs-property">filePaths</span>[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(filePath, <span class="hljs-string">&#x27;utf8&#x27;</span>);<br><span class="hljs-keyword">return</span> content.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> [];<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装所有依赖</span><br>npm install<br><br><span class="hljs-comment"># 构建并运行</span><br>npm start<br></code></pre></td></tr></table></figure><h2 id="添加数据库"><a href="#添加数据库" class="headerlink" title="添加数据库"></a>添加数据库</h2><p>目前数据库中存储两个字段，原文和译文。翻译时先查找数据库中是否有原文，如果有直接获取，没有再调用翻译api。<br>使用better-sqlite3时出现了一些问题：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error: </span>The module &#x27;/LineByLine/node_modules/better-sqlite3/build/Release/better_sqlite3.node&#x27;<br>was compiled against a different Node.js version using<br>NODE_MODULE_VERSION 131. This version of Node.js requires<br>NODE_MODULE_VERSION 132. Please try re-compiling or re-installing<br>the module (for instance, using `npm rebuild` or `npm install`).<br></code></pre></td></tr></table></figure><p>故暂时使用sqlite3：<code>npm install sqlite3</code>。</p><p>database.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sqlite3 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;sqlite3&#x27;</span>).<span class="hljs-title function_">verbose</span>();<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>); <br><br><span class="hljs-comment">// 创建数据库连接</span><br><span class="hljs-keyword">const</span> db = <span class="hljs-keyword">new</span> sqlite3.<span class="hljs-title class_">Database</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;data.db&#x27;</span>), <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (err) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Database connection error:&#x27;</span>, err);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Connected to database&#x27;</span>);<br>&#125;<br>&#125;);<br><br><span class="hljs-comment">// 创建表</span><br>db.<span class="hljs-title function_">serialize</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>db.<span class="hljs-title function_">run</span>(<span class="hljs-string">`</span><br><span class="hljs-string">CREATE TABLE IF NOT EXISTS translations (</span><br><span class="hljs-string">id INTEGER PRIMARY KEY AUTOINCREMENT,</span><br><span class="hljs-string">original TEXT UNIQUE,</span><br><span class="hljs-string">translated TEXT</span><br><span class="hljs-string">)</span><br><span class="hljs-string">`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 获取翻译</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTranslation</span>(<span class="hljs-params">text</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>db.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;SELECT translated FROM translations WHERE original = ?&#x27;</span>, [text], <span class="hljs-function">(<span class="hljs-params">err, row</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (err) <span class="hljs-title function_">reject</span>(err);<br><span class="hljs-title function_">resolve</span>(row ? row.<span class="hljs-property">translated</span> : <span class="hljs-literal">null</span>);<br>&#125;);<br>&#125;);<br>&#125;<br><br><span class="hljs-comment">// 保存翻译</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">saveTranslation</span>(<span class="hljs-params">original, translated</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> sql = <span class="hljs-string">`</span><br><span class="hljs-string">INSERT INTO translations (original, translated)</span><br><span class="hljs-string">VALUES (?, ?)</span><br><span class="hljs-string">ON CONFLICT(original)</span><br><span class="hljs-string">DO UPDATE SET translated = excluded.translated</span><br><span class="hljs-string">`</span>;<br>db.<span class="hljs-title function_">run</span>(sql, [original, translated], <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (err) <span class="hljs-title function_">reject</span>(err);<br><span class="hljs-title function_">resolve</span>();<br>&#125;);<br>&#125;);<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>db,<br>getTranslation,<br>saveTranslation<br>&#125;;<br></code></pre></td></tr></table></figure><p>main.js加入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> db = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./database&#x27;</span>);<br><br><span class="hljs-comment">// 读取译文</span><br>ipcMain.<span class="hljs-title function_">handle</span>(<span class="hljs-string">&#x27;get-translation&#x27;</span>, <span class="hljs-keyword">async</span> (event, text) =&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">getTranslation</span>(text);<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Translation query error:&#x27;</span>, err);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;);<br><br><span class="hljs-comment">// 存储译文</span><br>ipcMain.<span class="hljs-title function_">handle</span>(<span class="hljs-string">&#x27;save-translation&#x27;</span>, <span class="hljs-keyword">async</span> (event, original, translated) =&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">await</span> <span class="hljs-title function_">saveTranslation</span>(original, translated);<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Translation save error:&#x27;</span>, err);<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="加入部分翻译功能"><a href="#加入部分翻译功能" class="headerlink" title="加入部分翻译功能"></a>加入部分翻译功能</h2><h3 id="模拟翻译接口"><a href="#模拟翻译接口" class="headerlink" title="模拟翻译接口"></a>模拟翻译接口</h3><p>部分翻译功能可以使用各大翻译软件的接口，为了便于测试，编写一个本地的接口模拟翻译接口<br><code>npm install express</code><br>mockTranslateServer.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br><br><span class="hljs-comment">// 模拟翻译数据库</span><br><span class="hljs-keyword">const</span> mockTranslations = &#123;<br><span class="hljs-comment">// 常用词汇示例</span><br><span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-string">&#x27;你好&#x27;</span>,<br><span class="hljs-string">&#x27;world&#x27;</span>: <span class="hljs-string">&#x27;世界&#x27;</span>,<br><span class="hljs-string">&#x27;book&#x27;</span>: <span class="hljs-string">&#x27;书&#x27;</span>,<br><span class="hljs-string">&#x27;read&#x27;</span>: <span class="hljs-string">&#x27;阅读&#x27;</span>,<br><span class="hljs-string">&#x27;welcome&#x27;</span>: <span class="hljs-string">&#x27;欢迎&#x27;</span>,<br><span class="hljs-comment">// 可以根据需要添加更多</span><br>&#125;;<br><br><span class="hljs-comment">// 支持 JSON 请求体</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());<br><br><span class="hljs-comment">// 模拟翻译 API 端点</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/translate&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> requestBody = req.<span class="hljs-property">body</span>;<br><span class="hljs-comment">// 验证请求格式</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(requestBody) || !requestBody[<span class="hljs-number">0</span>]?.<span class="hljs-property">text</span>) &#123;<br><span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>(&#123;<br><span class="hljs-attr">error</span>: &#123;<br><span class="hljs-attr">code</span>: <span class="hljs-number">400</span>,<br><span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Invalid request format&quot;</span><br>&#125;<br>&#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> textToTranslate = requestBody[<span class="hljs-number">0</span>].<span class="hljs-property">text</span>;<br><br><span class="hljs-comment">// 模拟翻译逻辑</span><br><span class="hljs-keyword">let</span> translatedText;<br><span class="hljs-keyword">if</span> (mockTranslations[textToTranslate.<span class="hljs-title function_">toLowerCase</span>()]) &#123;<br><span class="hljs-comment">// 如果在预设词典中找到对应翻译</span><br>translatedText = mockTranslations[textToTranslate.<span class="hljs-title function_">toLowerCase</span>()];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 简单的模拟翻译规则：在原文后添加&quot;[已翻译]&quot;</span><br>translatedText = <span class="hljs-string">`<span class="hljs-subst">$&#123;textToTranslate&#125;</span>[已翻译]`</span>;<br>&#125;<br><br><span class="hljs-comment">// 模拟 API 响应格式</span><br><span class="hljs-keyword">const</span> response = [&#123;<br><span class="hljs-attr">translations</span>: [&#123;<br><span class="hljs-attr">text</span>: translatedText,<br><span class="hljs-attr">to</span>: <span class="hljs-string">&quot;zh&quot;</span><br>&#125;]<br>&#125;];<br><br><span class="hljs-comment">// 模拟随机延迟（100-500ms），更真实地模拟网络请求</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>res.<span class="hljs-title function_">json</span>(response);<br>&#125;, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">400</span> + <span class="hljs-number">100</span>);<br>&#125;);<br><br><span class="hljs-comment">// 添加错误处理中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">stack</span>);<br>res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">json</span>(&#123;<br><span class="hljs-attr">error</span>: &#123;<br><span class="hljs-attr">code</span>: <span class="hljs-number">500</span>,<br><span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Internal server error&quot;</span><br>&#125;<br>&#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Mock translation server running at http://localhost:<span class="hljs-subst">$&#123;port&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>node mockTranslateServer.js</code>，开启模拟接口</p><h3 id="翻译文本"><a href="#翻译文本" class="headerlink" title="翻译文本"></a>翻译文本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetch</span> = (<span class="hljs-params">...args</span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;node-fetch&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; <span class="hljs-keyword">default</span>: fetch &#125;</span>) =&gt;</span> <span class="hljs-title function_">fetch</span>(...args));<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TRANSLATOR_API_KEY</span> = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TRANSLATOR_URL</span> = <span class="hljs-string">&#x27;http://localhost:3000/translate&#x27;</span>; <span class="hljs-comment">// 修改为本地服务器地址</span><br><br><span class="hljs-comment">// 翻译文本</span><br>ipcMain.<span class="hljs-title function_">handle</span>(<span class="hljs-string">&#x27;translate-text&#x27;</span>, <span class="hljs-keyword">async</span> (event, text) =&gt; &#123;<br><span class="hljs-comment">// 先查询数据库，看看是否已有翻译</span><br><span class="hljs-keyword">const</span> existingTranslation = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getTranslation</span>(text);<br><span class="hljs-keyword">if</span> (existingTranslation) &#123;<br><span class="hljs-keyword">return</span> existingTranslation;<br>&#125;<br><br><span class="hljs-comment">// 如果没有，调用翻译 API</span><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-variable constant_">TRANSLATOR_URL</span>, &#123;<br><span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br><span class="hljs-attr">headers</span>: &#123;<br><span class="hljs-string">&#x27;Ocp-Apim-Subscription-Key&#x27;</span>: <span class="hljs-variable constant_">TRANSLATOR_API_KEY</span>,<br><span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>&#125;,<br><span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>([&#123; text &#125;]),<br>&#125;);<br><br><span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br><span class="hljs-keyword">const</span> translatedText = data[<span class="hljs-number">0</span>]?.<span class="hljs-property">translations</span>[<span class="hljs-number">0</span>]?.<span class="hljs-property">text</span> || <span class="hljs-string">&#x27;&#x27;</span>;<br><br><span class="hljs-comment">// 存入数据库</span><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">saveTranslation</span>(text, translatedText);<br><br><span class="hljs-keyword">return</span> translatedText;<br>&#125;);<br></code></pre></td></tr></table></figure><p>修改App.js，点击翻译按钮后显示译文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">translateLine</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">line</span>) =&gt; &#123;<br><span class="hljs-keyword">const</span> translated = <span class="hljs-keyword">await</span> ipcRenderer.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">&#x27;translate-text&#x27;</span>, line);<br><span class="hljs-title function_">setTranslations</span>(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> (&#123; ...prev, [line]: translated &#125;));<br>&#125;;<br><br><span class="hljs-keyword">return</span> (<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">padding:</span> &#x27;<span class="hljs-attr">20px</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleFileSelect&#125;</span>&gt;</span>选择文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">marginTop:</span> &#x27;<span class="hljs-attr">20px</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml">&#123;lines.map((line, index) =&gt; (</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">marginBottom:</span> &#x27;<span class="hljs-attr">10px</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;line&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> translateLine(line)&#125;&gt;翻译<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &#x27;<span class="hljs-attr">gray</span>&#x27; &#125;&#125;&gt;</span>&#123;translations[line]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">))&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p>修改为按行显示，修改App.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 常见的尊称和后缀</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TITLES</span> = [<br><span class="hljs-string">&#x27;M(?:r|rs|s)\\.&#x27;</span>, <span class="hljs-comment">// Mr., Mrs., Ms.</span><br><span class="hljs-string">&#x27;D(?:r)\\.&#x27;</span>, <span class="hljs-comment">// Dr.</span><br><span class="hljs-string">&#x27;P(?:rof)\\.&#x27;</span>, <span class="hljs-comment">// Prof.</span><br><span class="hljs-string">&#x27;R(?:ev)\\.&#x27;</span>, <span class="hljs-comment">// Rev.</span><br><span class="hljs-string">&#x27;H(?:on)\\.&#x27;</span>, <span class="hljs-comment">// Hon.</span><br><span class="hljs-string">&#x27;J(?:r)\\.&#x27;</span>, <span class="hljs-comment">// Jr.</span><br><span class="hljs-string">&#x27;S(?:r|t)\\.&#x27;</span>, <span class="hljs-comment">// Sr., St.</span><br><span class="hljs-string">&#x27;U\\.S\\.&#x27;</span> <span class="hljs-comment">// U.S.</span><br>];<br><br><span class="hljs-comment">// 选择文件，将每句话分割开</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFileSelect</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">const</span> fileContent = <span class="hljs-keyword">await</span> ipcRenderer.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">&#x27;select-file&#x27;</span>);<br><span class="hljs-keyword">if</span> (!fileContent || fileContent.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;文件内容为空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>  <br><span class="hljs-keyword">const</span> text = fileContent.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\n/g</span>, <span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">// 合并所有行，并替换换行符为空格</span><br><span class="hljs-keyword">const</span> sentenceEndRegex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<br><span class="hljs-string">`(?&lt;!<span class="hljs-subst">$&#123;TITLES.join(<span class="hljs-string">&#x27;|&#x27;</span>)&#125;</span>\\s?)`</span> + <span class="hljs-comment">// 确保不在尊称之后（允许尊称后有空格）</span><br><span class="hljs-string">`(?&lt;=[。！？.!?])\\s+`</span>, <span class="hljs-comment">// 句子结束标点后的空格</span><br><span class="hljs-string">&#x27;gi&#x27;</span> <span class="hljs-comment">// 添加 &#x27;i&#x27; 标志，大小写不敏感</span><br>);<br><br><span class="hljs-comment">// 按标点符号拆分</span><br><span class="hljs-keyword">const</span> sentences = text<br>.<span class="hljs-title function_">split</span>(sentenceEndRegex) <span class="hljs-comment">// 忽略常见缩写</span><br>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.<span class="hljs-title function_">trim</span>())<br>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">setLines</span>(sentences);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;读取文件失败:&quot;</span>, error);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="读取pdf文件"><a href="#读取pdf文件" class="headerlink" title="读取pdf文件"></a>读取pdf文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 读取 pdf 文件</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileExt === <span class="hljs-string">&#x27;.pdf&#x27;</span>) &#123;<br><span class="hljs-keyword">const</span> pdfjsLib = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;pdfjs-dist/build/pdf.mjs&#x27;</span>);<br><span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">await</span> pdfjsLib.<span class="hljs-title function_">getDocument</span>(filePath).<span class="hljs-property">promise</span>;<br><span class="hljs-keyword">const</span> numPages = pdf.<span class="hljs-property">numPages</span>;<br><span class="hljs-keyword">const</span> textContent = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pageNum = <span class="hljs-number">1</span>; pageNum &lt;= numPages; pageNum++) &#123;<br><span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> pdf.<span class="hljs-title function_">getPage</span>(pageNum);<br><span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">getTextContent</span>();<br><span class="hljs-keyword">const</span> pageText = content.<span class="hljs-property">items</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">str</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>textContent.<span class="hljs-title function_">push</span>(pageText);<br>&#125;<br><br>content = textContent;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读取epub文件"><a href="#读取epub文件" class="headerlink" title="读取epub文件"></a>读取epub文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileExt === <span class="hljs-string">&#x27;.epub&#x27;</span>) &#123;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">EPub</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;epub&#x27;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> epub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EPub</span>(filePath, <span class="hljs-string">&#x27;/images/&#x27;</span>, <span class="hljs-string">&#x27;/chapters/&#x27;</span>);<br><br>epub.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 获取所有章节内容</span><br><span class="hljs-keyword">const</span> chapters = [];<br><br><span class="hljs-comment">// 使用 Promise.all 和 map 来并行处理所有章节</span><br><span class="hljs-keyword">const</span> chapterPromises = epub.<span class="hljs-property">flow</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">chapter</span> =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolveChapter, rejectChapter</span>) =&gt;</span> &#123;<br>epub.<span class="hljs-title function_">getChapter</span>(chapter.<span class="hljs-property">id</span>, <span class="hljs-function">(<span class="hljs-params">error, text</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (error) &#123;<br><span class="hljs-title function_">rejectChapter</span>(error);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 将 HTML 转换为纯文本</span><br><span class="hljs-keyword">const</span> textContent = text.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;[^&gt;]+&gt;/g</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\n\s*\n/g</span>, <span class="hljs-string">&#x27;\n&#x27;</span>)<br>.<span class="hljs-title function_">trim</span>();<br><span class="hljs-title function_">resolveChapter</span>(textContent);<br>&#125;<br>&#125;);<br>&#125;);<br>&#125;);<br><br><span class="hljs-keyword">const</span> chapterContents = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(chapterPromises);<br><span class="hljs-title function_">resolve</span>(chapterContents);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br><span class="hljs-title function_">reject</span>(error);<br>&#125;<br>&#125;);<br><br>epub.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br><span class="hljs-title function_">reject</span>(error);<br>&#125;);<br><br>epub.<span class="hljs-title function_">parse</span>();<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="电子书阅读器"><a href="#电子书阅读器" class="headerlink" title="电子书阅读器"></a>电子书阅读器</h1><p>先做阅读器，然后再加上句子拆分和翻译功能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/01/18/Kali%20Linux/"/>
    <url>/2025/01/18/Kali%20Linux/</url>
    
    <content type="html"><![CDATA[<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>安装snort报错：Unable to locate package snort<br>解决方案：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo nano /etc/apt/sources.list<br>deb http:<span class="hljs-comment">//http.us.debian.org/debian/ bullseye non-free contrib main</span><br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br>sudo apt-<span class="hljs-built_in">get</span> install snort<br></code></pre></td></tr></table></figure><p>来源 ：<a href="https://www.reddit.com/r/Kalilinux/comments/wg3gkn/snort_on_kali_linux_will_not_install/">https://www.reddit.com/r/Kalilinux/comments/wg3gkn/snort_on_kali_linux_will_not_install/</a></p><h2 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h2><p>pwd：present working directory 查看当前工作目录<br>whoami：查看登录用户<br>cd：change directory 切换目录。可以用<code>cd .. ..</code>来向上两层<br>ls：list 查看目录内容，-l 表示long 显示文件详细信息，-a 查看隐藏文件<br><code>-- help</code>：几乎所有命令都有帮助文件，Linux约定在单词前加两个破折号，在字母前加单破折号。也可以用<code>-?</code>查看帮助。<br>man：多数命令都有手册<br>locate：后跟一个关键词，遍历整个文件系统查找。结果可能很多而且通常每天更新一次。<br>whereis：只返回二进制文件和man页<br>which：返回PATH变量中二进制文件的位置<br>find：最强大最灵活的搜索程序，基本语法：<code>find directory options expression</code>。例如从根目录搜索名为apache2的文件：<code>find / -type f -name apache2</code>。f表示普通文件。仅显示确切的匹配项，可以加上通配符。<br>通配符：<code>* . ? []</code></p><p>grep：过滤器，输出从一条命令通过管道（<code>｜</code>）传输到另一个命令时，通常会使用grep。<br>ps：processes 显示进程信息。ps aux显示运行的所有进程。<code>ps aux ｜ grep apache2</code>显示所有服务然后将输出发送到grep。也可以cat输出文件内容后用grep过滤。关键词</p><p>cat：concatenate 显示文件内容以及创建小文件。cat后跟文件名会显示文件内容，cat后加重定向”<code>&gt;</code>“创建文件，用两个重定向符”<code>&gt;&gt;</code>“，追加内容。<br>touch：最初的开发目的是更改文件的某些详细信息，例如创建或修改的时间。如果文件名不存在，创建该空文件。<br>mkdir：创建目录<br>cp：复制文件<br>mv：移动文件，也可以重命名文件<br>rm：删除文件，-r 删除整个目录<br>rmdir：删除空目录</p><p>echo $SHELL：查看正在使用的shell。如果是bash，编辑<code>~/.bash_profile</code> 或 <code>~/.bashrc</code>。如果是zsh，编辑 <code>~/.zshrc</code>。最后用source后跟编辑的配置文件来重新加载配置文件。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>head：查看文件前10行，-20 显示前20行。<br>tail：类似于head，查看后10行，-20 显示后20行。<br>nl：显示文件行号</p><p>如果想看一个文件的第507-512行：<code>nl -n+507 filename | head -n 6</code>。</p><p>sed：搜索文本出现次数，并且对其执行某些操作。<code>sed s/mysql/MYSQL/g filename &gt; filename2</code>，s命令执行搜索，两个关键词，g表示全局替换，结果保存在一个新文件中。去掉g可以只替换第一个匹配项。g换成2可以只替换第二个匹配项。</p><p>more：查看文件内容，一次显示一页。<br>less：与more类似，按下斜杠/进行搜索。按下n查看下一个匹配项。</p><h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><p>ifconfig：检查活动网络接口并与之交互。eth0表示Ethernet0。网络硬件唯一地址MAC media access control。Bcast广播地址，用于向子网所有IP发送信息。Mask网络掩码，确定IP地址的哪一部分连接到本地网络。lo表示localhost本地回环地址。wlan表示无线接口或适配器。来自ifconfig的信息可以连接和操作局域网LAN设置。<br>加上两个参数：接口和IP地址，更改接口的IP地址。也可以修改接口的网络掩码和广播地址。<br><code>ifconfig eth0 down</code>关闭接口，然后<code>ifconfig eth0 hw ether newMAC</code>伪装MAC地址，ifconfig eth0 up开启接口。（hw指硬件hard ware）</p><p>iwconfig：如果有无线适配器，可以查看适配器的IP地址，MAC地址，所处的模式等。无线扩展到模式Managed，Monitor，promiscuous。promiscuous模式用来破解无线密码。</p><p>linux有一个动态主机配置协议dynamic host configuration protocol DHCP服务器。DHCP服务器为子网上的所有系统分配IP地址，并保留任何时候将哪个IP地址分配给哪台计算机的日志文件。有助于攻击后追踪黑客。<br><code>dhclient eth0</code>从指定的网络接口eth0发送DHCPDISCOVER请求，然后从DHCP服务器接收DHCPOFFER并使用dhcp请求向DHCP服务器分配IP。</p><p>DNS：domain name system域名系统。旨在将域名转换为IP地址。dig命令，收集有关目标域的DNS信息，此信息可能包含目标名称服务器nameserver（将目标名称转换为IP地址的服务器）的IP地址，目标的电子邮件服务器以及可能的子域和IP地址。<br><code>dig hackers-arise.com ns</code>。ns表示nameserver。mx选项表示mail exchange server，查看连接到域的电子邮件服务器地址。<br>最常见的DNS服务器是伯克利internet name domain BIND。<br>在/etc/resolv.conf中修改DNS服务器。<code>echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/resolv.conf</code><br>注：如果使用的DHCP地址，而且DHCP提供了DNS设置，则DHCP服务器会在续订DHCP地址时替换文件内容。</p><p>/etc/hosts文件与DNS类似，指定自己的IP地址-域名映射。这对于劫持局域网上的TCP连接以使用dnsspoof等工具将流量定向到恶意web服务器非常有用。确保在IP地址和域名之间按Tab而不是空格。了解dnsspoof和Ettercap等工具，可以使用hosts文件将LAN上访问某网站到任何流量定向到其他服务器。</p><h2 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h2><p>apt-get<br><code>apt-cache search keyword</code>，检查软件包是否在自己的存储库中。<br><code>apt-get install packagename</code>，安装软件包<br><code>apt-get remove packagename</code>，删除软件包。仅用remove不会删除配置文件，重新安装时无需重新配置。<code>apt-get purge packagename</code>，删除软件包及其配置文件。<br><code>apt-get update</code>，更新所有软件包。更新与升级有区别：更新只是更新软件包列表。<br><code>apt-get upgrade</code>，升级现有软件包，需要使用root身份。<br>存储库：保存特定Linux发行版软件的服务器。可以在kali中添加几个备份存储库，以免在kali存储库中找不到特定软件。/etc/apt/sources.list为存储库文件，修改此文件来指示从哪些存储库下载文件。注：解决报错中的第一个问题的方案就是添加一个存储库。<br>基于GUI的安装工具：Synaptic和Gdebi</p><h2 id="文件和目录的权限控制"><a href="#文件和目录的权限控制" class="headerlink" title="文件和目录的权限控制"></a>文件和目录的权限控制</h2><p>可以为”文件的所有者”，”特定用户组”，”所有其他用户”指定权限。<br>特定级别的权限：r读取（打开和查看文件），w写入（查看和编辑文件），x执行文件（不一定查看或编辑）。<br>chown：change owner修改文件所有者<br>chgrp：change group更改文件所有权到另一个组<br>chmod：change mode修改权限，可以用十进制的方式，每个数字表示一组rwx权限。也可以用UGO的方式，u表示用户，g表示组，o表示其他人。<code>chmod u-w,o+x filename</code>，删除用户的写权限，添加其他用户的执行权限。<br>Linux自动为所有文件和目录分配默认权限，分别为666和777。也就是说，默认情况下，无法在下载文件后立即执行文件。<br>umask：修改默认权限，umask是三位数字，创建文件或目录时，权限为默认值减umask。在kali中，umask预配置为022。每个用户可以在/home/username/.profile修改自己的umask。<br>三种特殊权限：SUID，具有SUID的文件始终以拥有该文件的用户身份执行，在常规权限前添4。SGID，如果在文件上设置，允许以拥有该文件的组身份执行该文件，类似于SUID。如果在目录上设置，则目录中创建的任何文件的组所有权都将设置为目录所有者的组所有权，在常规权限前添2。Sticky Bit已经过时<br><code>find / -user root -perm -4000</code>，查找有SUID的文件。<br>第一组权限用s代替x，表示设置了SUID。这意味着运行该文件的任何人都拥有root用户的权限。</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程是一个正在运行和使用资源的程序。ps命令查看运行的进程。创建进程时按顺序为每个进程分配一个唯一的进程ID（PID）。加上选项aux，显示所有用户在系统上运行的所有进程，加选项-ef输出类似。列名的解释：user，调用进程的用户。command，启动进程的命令名称。<br>ps命令默认按启动顺序也就是PID升序排列的。<br>top命令可以按照使用资源排序。按H或者？显示交互式命令列表。<br>nice命令建议修改进程优先级。范围从-20到+19，默认为0。<code>nice -n -10 processName</code>，将nice值减10，提高优先级，<code>nice -n 10 processName</code>，将nice值加10，对其他用户和进程友好。<code>renice 20 PID</code>，修改PID的nice值。<br>kill：后面跟<code>-signal</code>然后跟PID，有64个signal，不提供的话，默认是sigterm。<code>kill -1 PID</code>，hup信号，使用相同的PID重新启动。<code>kill -9 PID</code>，绝对kill信号，将进程的资源发送到特殊设备/dev/null来强制进程停止。killall命令类似于kill，不用PID，而是用进程名称。<br>后台运行进程，命令后加<code>&amp;</code>。fg命令（foreground）后面跟PID，将后台运行的进程移动到前台。<br>调度进程：安排进程在一天中的特定时间运行。at命令是一个守护进程一个后台进程，用于安排作业在将来的某个时间点运行一次。crond命令适合将任务安排在每天、每周或每月发生。at命令，进入交互模式，输入执行的时间点，回车后输入要执行的程序。<br>黑客通常需要在他们想要杀死的目标上找到进程，例如防病毒软件或防火墙。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p> 从技术上讲，有两种类型的变量：shell和environment。环境变量是系统范围变量，被shell或进程继承。而shell变量通常以小写形式给出，仅在设置它们的shell中有效。变量是键值对，多个值的话用冒号隔开<code>key=value1:value2:value3</code>。如果值中有空格，需要用引号包含。<br> env命令查看默认环境变量，set命令列出系统唯一的所有环境变量，可以用<code>set | more</code>，更容易查看。也可以用grep过滤<code>set | grep HISTSIZE</code>，此变量包含命令历史记录文件将存储的最大命令数。这些命令是您之前在此会话中键入到命令提示符中的任何命令，可以使用向上和向下箭头键调用。<br><code>HISTSIZE=0</code>，在session中修改该变量，系统就不会存储以前输入的命令。这样修改环境变量，该更改仅发生在特定环境中，如果在kali中执行，该环境就是bash shell会话。当关闭终端后，更改将会丢失。<code>export HISTSIZE</code>，永久化更改。<br>PS1环境变量是shell提示符的格式。<br>环境中最重要的变量之一是PATH，控制shell在系统上查找您输入的命令的位置。<code>echo $PATH</code>查看变量。<br><code>PATH=$PATH:/root/newhackingtool</code>，将新目录添加到PATH变量中。<code>$PATH</code>就是以前的PATH，后面加个冒号就是在后面再填上一个值，然后重新赋值给PATH。<br>直接在shell中用变量名=值来自定义变量，用unset命令删除变量。</p><h2 id="bash脚本"><a href="#bash脚本" class="headerlink" title="bash脚本"></a>bash脚本</h2><p>脚本语言ruby（metasploit使用ruby编写的），python，perl（最好的文本操作脚本语言）。<br>shell是用户和操作系统之间的接口。<br>打开文本编辑器，首先，需要告诉操作系统要为脚本使用哪个解释器，输入shebang（就是一个井号加一个感叹号），后面加上<code>/bin/bash</code>，指示希望操作系统使用bash shell解释器。<br>echo命令，告诉系统简单的在显示器显示echo后面的内容，字符串用双引号引起来。注释以井号开头。<br>刚保存的文件没有执行权限，可以使用<code>chmod 755</code>修改<br>read命令，后面跟变量名，变量存储用户输入。用<code>$</code>后面跟变量名来使用变量的值。</p><h2 id="压缩和存档"><a href="#压缩和存档" class="headerlink" title="压缩和存档"></a>压缩和存档</h2><p>压缩分为有损和无损。有损压缩会丢失信息的完整性，这种类型的压缩适用于图形视频和音频，这些文件中，文件中的微小差异几乎不明显。mp3，mp4，png，jpg都是有损压缩算法。<br>tar：tape archive磁带存档<br>-c 创建压缩文件<br>-v 显示进度<br>-x 解压模式<br>-f 要压缩或解压的文件，-f必须位于最后一个参数<br>-z gzip模式，一般位于第一个参数位置<br>-C 解压目的地<br>-t 查看压缩文件的内容</p><p>压缩时常用组合：<br>tar -cvf test.tar 1.txt 2.txt 3.txt<br>tar -zcvf text.tar.gz 1.txt 2.txt 3.txt</p><p>解压时常用组合<br>tar -xvf name.tar<br>tar -xvf name.tar -C /…<br>tar -zxvf name.tar.gz</p><h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p>用于探测系统以查看它是否连接到网络并找出哪些端口是打开的。从发现的开放端口中，可以推测目标系统上运行了哪些服务。<br>最简单的形式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bnf">nmap <span class="hljs-attribute">&lt;type of scan&gt;</span><span class="hljs-attribute">&lt;target IP&gt;</span><span class="hljs-attribute">&lt;optionally, target port&gt;</span><br><span class="hljs-attribute">&lt;扫描类型&gt;</span><span class="hljs-attribute">&lt;目标 IP&gt;</span><span class="hljs-attribute">&lt;可选，目标端口&gt;</span><br></code></pre></td></tr></table></figure><p>最简单最可靠的nmap扫描是TCP连接扫描，用<code>-sT</code>指定。<br><code>nmap -sT 192.168.181.1 -p 3306</code>，扫描该IP的3306端口是否打开。</p><p>扫描局域网内的3306端口：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">nmap</span> -sT <span class="hljs-number">192.168</span>.<span class="hljs-number">101.0</span>/<span class="hljs-number">24</span> -<span class="hljs-keyword">p</span> <span class="hljs-number">3306</span> &gt; /dev/null -oG MySQLscan<br><span class="hljs-keyword">cat</span> MySQLscan | <span class="hljs-keyword">grep</span> <span class="hljs-keyword">open</span> &gt; MySQLscan2<br></code></pre></td></tr></table></figure><p>将标准nmap输出丢弃（如果是远程使用脚本，需要将输出隐藏起来），-oG表示将结果以grep-able格式发送到文件中。</p><h2 id="Snort"><a href="#Snort" class="headerlink" title="Snort"></a>Snort</h2><p>世界上最好的网络入侵检测系统network intrusion detection system NIDS，通常用于检测黑客的入侵，如果想成为成功的黑客，必须熟悉NIDS如何阻止攻击，以及如何滥用NIDS来避免被发现。</p><h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h2><p>最流行的渗透测试和黑客框架。漏洞利用框架。<br>/usr/share/wordlists/metasploit。包含多个单词列表，用于暴力破解密码。<br>msfconsole命令，启动metasploit。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/01/13/MySQL/"/>
    <url>/2025/01/13/MySQL/</url>
    
    <content type="html"><![CDATA[<p> mysql可以分为客户端和服务端，服务器接收客户端发送的请求，与存储的数据进行交互，然后向客户端响应信息。客户端和服务器都是一个进程，所以它们之间的通信是进程间通信。服务器启动时会默认申请3306端口号，在这个端口号上等待客户端进程进行连接，也就是服务器默认监听3306端口。<br> ![[IMG_629E544D6413-1.jpeg]]</p><p> 连接管理：<br> 每当一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程专门处理与该客户端的交互，当该客户端退出时，服务器不会立即销毁线程，而是会将线程缓存起来，另一个客户端连接时，将缓存的线程分配给新的客户端，避免频繁创建和销毁线程。</p><p> 查询缓存（弃用）：处理过的请求和结果缓存起来，下一次有一样的请求，直接从缓存里找。如果请求文本中有任何不一样，都不会命中缓存。如果请求中包含某些系统函数、用户自定义变量和函数、系统表，则请求不会缓存，例如请求中有now函数，两次调用返回的结果不应该一样。缓存系统会监测缓存涉及的表，如果表有修改，则删除有关的查询缓存。</p><p> 语法解析：判断请求的语法是否正确，算是一个编译过程，涉及词法解析，语法分析，语义分析等阶段。</p><p> 查询优化：语法解析后，服务器获取到了需要的信息，例如要查询的表和列是哪些，搜索条件等。优化程序会对语句进行优化，如外连接转换为内连接、表达式简化、子查询转为连接等等。优化的结果是生成一个执行计划，执行计划表明了应该使用哪些索引执行查询，表之间的连接顺序是啥样等等。可以用explain语句查看语句的执行计划。</p><p> 存储引擎：以前叫做表处理器，功能是接收上层传下来的指令，然后对表中的数据进行读取或写入操作。表是由一行一行的记录组成的，但这是一个逻辑上的概念。存储引擎负责：在物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，等等。处理请求的过程划分为server层和存储引擎层，上面说的从连接管理到查询优化这些不涉及真实数据存取划分为server层的功能。各种不同的存储引擎为server层提供统一的调用接口，包含了几十个底层函数，例如“读取索引第一条记录”，“读取索引下一条记录”等等。server层与存储引擎层交互时，一般是以记录为单位的，（记录就是一条或者说一行数据）。返回记录时，server层在判断某条记录符合要求之后，先将其发送到一个缓冲区，等到该缓冲区满了，才向客户端发送真正的记录，缓冲区大小由系统变量net_buffer_length控制，（缓冲区的作用是减少网络传输的频率和开销）。存储引擎最常用的是InnoDB和MyISAM，偶尔会有MEMORY，不同的存储引擎支持不同的功能。<br> show engines；查看服务器支持的存储引擎。存储引擎是负责对表中的数据进行读取和写入操作的，可以为不同的表设置不同的存储引擎，也就是说，不同的表，可以有不同的物理存储结构，不同的读取写入方式。</p><p>启动选项：mysql –help或mysqld –verbose –help等命令可以查看支持的启动选项，例如，–skip-networking或者–default-storage-engine=MyISAM。<br>命令行中设置的启动选项只对当次启动生效，编写配置文件会方便一些。程序启动时会在多个路径中查找配置文件，例如：/etc/mysql/my.cnf。</p><p>系统变量：查询<code>show variables [like &#39;something&#39;];</code>，like表达式中可以使用通配符来进行模糊查询。<br>系统变量有作用范围之分，分为global和session，也就是全局范围和会话范围。多个客户端可以连接到一个服务器上，客户端之间的系统变量可以是不同的。服务器会为每个连接的客户端维护一组会话变量。设置系统变量的命令：<code>set [global | session] key = value;</code>。用show variables查询时也可以在show后面加上范围。如果客户端修改了global范围的值，不会影响已经连入的客户端，只会影响后续连入的客户端。</p><p>服务器维护了一些状态变量，显示了程序的运行状态，使用<code>show [global|session] status [like &#39;&#39;];</code>来查看。</p><p>字符集：ASCII，128个字符，1个字节。GBK，1-2个字节。UTF-8，1-4个字节。在mysql中utf8是utf8mb3（阉割版，1-3个字节），要存储emoji需要用utf8mb4（1-4个字节存储，默认）。查看字符集：<code>show charset [like &#39;&#39;];</code><br>比较规则：<code>show collation [like &#39;&#39;];</code>，一种字符集可能对应多种比较规则。后缀中ci、ai等表示是否区分重音或大小写。<br>mysql有四个级别的字符集和比较规则：服务器级别，数据库级别，表级别，列级别。<br>服务器级别：系统变量character_set_server和collation_server，默认为utf8mb3。<br>数据库级别：可以在create database和alter database时指定character set和collate。系统变量character_set_database和collation_database。注意不能通过修改这两个系统变量来修改某数据库的字符集和比较规则，要修改需要使用alter database语句。<br>表级别：可以用create table和alter table语句指定字符集和比较规则。<br>列级别：对于存储字符串的列，同一个表中不同的列可以有不同的字符集和比较规则。可以用create table和alter table语句修改。注意如果列中原有的数据不能用修改后的字符集表示，则会报错。<br>字符集和比较规则相互关联，只修改一项，另一项会跟着变化。只修改字符集，比较规则变为修改后字符集默认的比较规则，只修改比较规则，字符集变为修改后比较规则对应的字符集。<br>知道了字符集，就能知道数据占用存储空间的大小。</p><p>如果编码和解码使用的字符集不一样，就会产生乱码。<br>![[截屏2025-01-14 10.10.32.png]]<br>![[IMG_AE4C10FA2F83-1.jpeg]]<br>这三个系统变量都是session级别。字符集的转换主要有下面几种：</p><ol><li>客户端发送的请求采用哪种字符集编码？操作系统的字符集</li><li>服务器接收到请求后认为它是用哪种字符集编码的？character_set_client</li><li>服务器在运行过程中会把请求转换为哪种字符集？character_set_connection</li><li>服务器向客户端返回结果时，采用哪种字符集？character_set_results</li><li>客户端收到响应后，怎么将其写到控制台中？操作系统的字符集</li></ol><p>InnoDB<br>数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位。页的大小默认为16kb，由系统变量innodb_page_siz指定，服务器运行时不能修改页的大小。<br>记录在磁盘上的存放形式被称为行格式，目前有四种行格式：compact，redundant，dynamic，compressed。<br>compact行格式：![[IMG_59A76F6AC2E9-1.jpeg]]<br>一条记录分为记录的额外信息和记录的真实数据。<br>记录的额外信息：服务器为了更好的管理记录而不得不额外添加的信息。</p><p>变长字段长度列表：mysql支持一些变长的数据类型，例如varchar(10)，真正存放的数据长度是不固定的，所以需要将数据占用的字节数存储起来，逆序放在变长字段长度列表中。<br>具体存储长度的时候，需要考虑使用一个还是两个字节存储长度，如果理论上的字段最长值&lt;=255，则可以用一个字节（两个16进制数，最大表示255）存储。注意InnoDB在读取该长度列表时先查看表结构，如果理论上存储的最大值不大于255，则会认为用一个字节存储长度。如果理论上的字段最长值&gt;255，则需要看实际存储的数据占用字节数L，如果L&lt;=127，则用一个字节，否则用两个字节。<br>读取变长字段长度列表时，先查看表结构，如果该字段最大长度小于等于255，则表示最多也就用一个字节，直接读取一个字节就行。那如果该字段最大长度大于255，则一个字节可能放不下，这时候要看实际数据的长度，InnoDB使用该字节的第一个位来进行标识，如果第一个位为0，则表示实际数据长度小于等于127，用一个字节存放，如果第一个位为1，则表示实际数据长度大于127，用两个字节存放长度。<br>综上所述，如果该变长字段允许存储的最大字节数超过255字节，并且真实数据占用的字节数超过127字节，则用两字节来表示真实数据占用的字节数，否则用一个字节。<br>另外，如果字段的内容为null，则长度列表不存储该字段长度。如果所有字段都不是变长的或者变长字段的值都为null的话，就不存在长度列表。</p><p>null值列表：将一条记录中值为null的列统一管理，将每个允许存储null的列对应一个二进制位，按照列顺序的逆序排列，二进制位为1时，表示该列对应的字段值为null。null值列表需要用整数个字节的位表示，不足的在高位补0。</p><p>记录头信息：固定5个字节，前4个位也被称为info bit。<br>![[IMG_C1CAB7D358A8-1.jpeg]]<br>记录的真实数据：除了真正的数据之外，mysql会为每个记录默认添加一些列（也称为隐藏列），![[IMG_003051D0EEE4-1.jpeg]]<br>InnoDB表的主键生成策略：优先使用用户自定义的主键，如果没有自定义，选择不允许存储null值的unique键作为主键，这类键也没有的话，就默认添加一个row_id作为主键。</p><p>char(M)列的存储格式：如果使用的是定长编码字符集，例如ascii，则char(10)占用的长度不会存放在变长字段长度列表中。但如果使用的是变长编码字符集，即使字段是char(10)，这一列的值占用的字节数也要存放在变长字段长度列表中。<br>还规定，采用变长字符集的char(M)列要求至少占用M个字节，而varchar没有这个要求。比如用utf8的char(10)列，即使存储一个空字符串，也要占用10个字节，主要是希望以后更新该字段时，如果新值还是小于10个字节的话，可以直接更新，不用重新分配空间。</p><p>在compact和redundant行格式中，对于占用存储空间非常多的列，在真实数据处只会存储一部分数据（前768字节），剩余的数据分散存储在几个其他的页中，然后在真实数据处使用20个字节存储指向这些页的地址和分散在其他页面中的数据占用的字节数。<br>dynamic和compressed行格式在处理溢出列时，将所有真实数据都存储到溢出页中，compressed还会用压缩算法对页面进行压缩。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/01/11/30%E5%A4%A9%E5%88%B6%E4%BD%9CC++%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2025/01/11/30%E5%A4%A9%E5%88%B6%E4%BD%9CC++%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="day01-从一个最简单的socket开始"><a href="#day01-从一个最简单的socket开始" class="headerlink" title="day01-从一个最简单的socket开始"></a>day01-从一个最简单的socket开始</h1><ul><li><a href="https://www.runoob.com/w3cnote/summary-of-network.html">计算机网络基础知识总结</a><br>首先在服务器，我们需要建立一个socket套接字，对外提供一个网络通信接口，在Linux系统中这个套接字竟然仅仅是一个文件描述符，也就是一个<code>int</code>类型的值！这个对套接字的所有操作（包括创建）都是最底层的系统调用。<br>了解什么是Linux系统调用和文件描述符，《现代操作系统》第四版第一章有详细的讨论。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2024/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><p>因特网中，计算设备例如PC、服务器、手机、手表等，称为主机host或端系统end system。<br>端系统通过通信链路communication link和分组交换机packet switch的网络连接到一起。<br>不同的链路以不同的速率传输数据，链路的传输速率以比特每秒bit/s或bps度量。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包用计算机网络的术语来说就是分组packet。<br>分组交换机从一条入通信链路接收到达的分组，并从它的一条出通信链路<font color="#2DC26B">转发</font>该分组。两种常见的分组交换机是路由器router和链路层交换机link-layer switch。链路层网络交换机通常用于接入网中，而路由器通常用于网络核心中。<br>用于传送分组的分组交换网络在许多方面类似于承载运输车辆的运输网络，分组交换机类似于交叉口。<br>端系统通过因特网服务提供商Internet Service Provider ISP接入因特网。每个ISP自身就是一个由多台分组交换机和多端通信链路组成的网络。<br>IP协议定义了在路由器和端系统之间发送和接收的分组格式。</p><p>从另一个角度描述因特网：为应用程序提供服务的基础设施<br>与因特网相连的端系统提供了一个套接字接口socket interface，该接口规定了运行在一个端系统上的程序请求因特网基础设施向另一个端系统上的特定目的地程序交付数据的方式。</p><p>端系统也称为主机host，因为它们容纳（即运行）应用程序，主机=端系统。主机有时被进一步划分为客户client和服务器server。<br>接入网是指将端系统物理连接到其边缘路由器的网络。边缘路由器是端系统到任何其他远程端系统到路径上的第一台路由器。<br>家庭接入有几种不同的方式：DSL、电缆、FTTH和5G固定式无线。数字用户线DSL使用现有的电话线。电缆使用现有的有线电视线。FTTH光纤到户，有两种光纤分布体系结构，有源光纤网络AON和无源光纤网络PON。家庭中绝大多数使用的都是PON，PON中，每个家庭都有一个光纤网络端接器ONT，由光纤连接到邻近的分配器（光分路器）splitter，分配器把一些家庭连接到一根共享的光纤。家庭中使用一台路由器与ONT相连。PON体系结构中，所有从OLT发送到分配器的分组在分配器（类似于一个电缆头端）处复制。<br>![[截屏2025-02-18 23.41.23.png]]<br>端系统彼此交换报文message。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称为分组packet。每个分组通过数据链路和分组交换机传送，交换机主要有路由器和链路层交换机两类。<br>如果经过一条链路发送一个L bit的分组，链路的传输速率为R bps，则传输该分组的时间为L/R s。<br>多数分组交换机使用存储转发传输机制，是指转发前必须接收到整个分组。<br>通过N条速率均为R的链路，发送一个分组需要的时间是：<code>N * L / R</code>，发送P个分组的时延是：<code>(N + P - 1) * L / R</code>，解释：1. 什么时候轮到最后一个分组开始发送？<code>(P - 1) * L / R</code>。2. 最后一个发送到目的地需要多少时间？<code>N * L / R</code><br>分组交换机对于每条与其相连的链路，具有一个输出缓存（输出队列），如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该分组在输出缓存中等待。因此除了上面说到的存储转发时延，分组还要承受输出缓存的排队时延。如果缓存满了，将会出现分组丢失（丢包）packet loss。<br>每个路由器具有一个转发表forwarding table。端到端选路过程可以用一个不使用地图而喜欢问路的汽车驾驶员来类比。<br>通过网络链路和交换机移动数据有两种基本方法：电路交换和分组交换。电路交换网络中，在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存，链路传输速率）。在分组交换网络中，这些资源不是预留的，会话的报文按需使用这些资源，后果可能是等待接入通信线路。传统的电话网络是电路交换网络的一个例子。<br>TODO：网络的网络：P21<br>时延：1. 处理时延：检查分组首部、决定将分组导向何处、检查比特级别的差错等等。2. 排队时延。3. 传输时延：分组长度L / 链路传输速率R。4. 传播时延：路由器之间的距离d / 传播速率s。<br>传输时延和传播时延的区别：传输时延是路由器推出分组所需要的时间，与路由器之间的距离无关。类比高速公路收费站，收费站是路由器，传输时延是收费站处理的时间，传播时延是在公路上行驶的时间。有时还会出现下面的情况：一个分组的前几个比特到达了一台路由器，而该分组中许多余下的比特仍然在前面的路由器中等待传输。<br>时延中最复杂和有趣的是排队时延，排队时延很大程度取决于流量到达该队列的速率、链路的传输速率和到达流量的性质（周期性到达还是突发到达）。假设所有分组由L bit组成，a为分组到达队列的平均速率（单位为分组每秒pkt/s），则La bps为比特到达队列的平均速率，R时传输速率，即从队列中推出比特的速率，单位为bps，那么<code>La / R</code>为流量强度，如果大于1，则表示比特到达的平均速率超过从该队列传输出去的速率，队列会逐渐增长。<br>Traceroute，假设源和目的地之间有N-1台路由器，源发送N个特殊的分组，分组有从1-N的标识，第n台路由器接收到第n个标识对应的分组后，会向源会送一个报文，这样就能重建分组从源到目的地所采用的路由。<br>瞬时吞吐量是主机接收到文件的速率（单位为bps，下载时显示的）。吞吐量取决于数据流过的链路的传输速率。当没有其他干扰流量时，吞吐量能近似为路径中的最小传输速率，但考虑干扰流量时，例如许多其他数据也通过该链路流动，那也可能会形成瓶颈链路。<br>![[IMG_004F48B1DAA9-1.jpeg]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/12/29/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/12/29/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="字符窜"><a href="#字符窜" class="headerlink" title="字符窜"></a>字符窜</h2><p>任何一个Java对象都可以转换成字符串。<br>String类没有提供方法来修改字符串中的某个字符，所以String类对象是不可变的，但我们可以修改字符串变量，让它指向另外的字符串。<br>不可变字符串有其优点：编译器可以让字符串共享。想象各个字符串存放在一个公共存储池中。</p><p>用equals方法检测两个字符串是否相等，equalsIgnoreCase方法忽略大小写判断是否相等。</p><h3 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h3><p>StringBuilder类可以构建字符串，先构建一个空的字符串构建器<code>StringBuilder builder = new StringBuilder();</code>，需要添加字符串时，调用append方法，字符串构建完成时，调用toString方法。<br>StringBuffer类的效率不如StringBuilder类，但StringBuffer允许采用多线程的方式添加或删除字符。如果所有字符串编辑操作都在单个线程中执行（通常如此），则使用StringBuilder类。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (variable: collection) statement<br><span class="hljs-title function_">for</span> <span class="hljs-params">(<span class="hljs-type">int</span> element: a)</span> <br>System.out.println();<br></code></pre></td></tr></table></figure><p>collection表达式必须是一个数组或者是一个实现了Iterable接口的类对象</p><h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><p><code>int[] a = b;</code> 此时，两个变量引用同一个数组。<br>要将数组中的所有值拷贝到一个新数组中，使用Arrays类的copyOf方法，其中第二个参数为新数组长度。该方法常用于增加数组的大小。</p><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p> <strong>LocalDate、LocalTime、LocalDateTime</strong> 和 <strong>Zoned</strong>使用参考<a href="">https://blog.csdn.net/qq_33697094/article/details/115454081</a><br> Date类表示时间点，LocalDate类日历表示法</p><h2 id="对象与泪"><a href="#对象与泪" class="headerlink" title="对象与泪"></a>对象与泪</h2><h3 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h3><p>面向对象程序设计OOP，是主流的程序设计范型。面向对象的程序由对象组成，每个对象包含对用户公开的特定功能和隐藏的实现。<br>类指定了如何构造对象。将类想象成模具，对象想象成模具制造出的成品。<br>由一个类构造contract对象的过程称为创建这个类的一个实例instance。</p><p>封装，有时称为信息隐藏。是将数据和行为组合在一个包中，对使用者隐藏具体的实现细节。<br>对象中的数据称为实例字段，操作数据的过程称为方法。<br>实现封装的关键在于，绝对不能让其他类中的方法直接访问这个类的实例字段。程序只能通过对象的方法与对象数据进行交互。封装为对象赋予了“黑盒”特征。</p><p>面向对象程序设计的另一个原则让用户自定义Java类变得更容易：可以通过扩展其他类来构建新类。这个新类具有被扩展的那个类的全部属性和方法。所有类都扩展自一个“神通广大的超类”Object类。</p><p>识别类的一个简单经验是在分析问题的过程中寻找名词，而方法对应动词。<br>类之间的关系有依赖、聚合和继承等。<br>依赖指一个类的方法要使用或操作另一个类的对象。应当尽可能减少相互依赖的类。这里的关键是，如果类A不知道B的存在，它就不会关心B的任何改变（这意味着B的改变不会在A中引入bug）</p><p>采用UML统一建模语言来绘制类图，来描述类之间的关系</p><h3 id="使用预定义的类"><a href="#使用预定义的类" class="headerlink" title="使用预定义的类"></a>使用预定义的类</h3><p>要想使用对象，首先必须构造对象，并指定其初始状态。然后对对象应用方法。<br>使用构造器或称构造函数来构造新实例。构造器是一种特殊的方法，作用是构造并初始化对象。构造器总是与类同名。以Date类为例，构造Date对象，在构造器前面加上new：<code>new Date();</code> ，可以将这个对象存放在一个变量中：<code>Date rightNow = new Date();</code> 。<br>对象变量和对象有区别，对象变量并不实际包含一个对象，它只是引用一个对象。<br>任何对象变量的值都是一个引用，指向存储在另一个地方的某个对象。new操作符的返回值也是一个引用。<br>可以把Java里面的对象变量看作C++中的对象指针。<br>所有的Java对象都存储在堆中。</p><h3 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h3><p>文件名必须与public类的名字匹配。一个源文件中只能有一个公共类，但可以有任意数目的非公共类。<br>构造器与类同名，构造器会将实例字段初始化为所希望的初始状态。<br>构造器总是结合new操作符来调用。<br>注意在所有方法中都不要使用与实例字段同名的变量。<br>Java10中，如果可以从变量的初始值推导出它们的类型，则可以用var声明局部变量，注意只能用于方法中的局部变量。</p><p>定义一个类时，最好清楚地知道哪些字段可能为null。如果有的字段可能为null，宽容的解决方案是使用Objects.requireNonNullElse方法，将null转换为适当的非null值，严格的解决方案是使用Objects.requireNonNull方法，如果用null构造对象，会产生NullPointerException异常。</p><p>可以将实例字段定义为final，这样的字段必须在构造对象时初始化，并且以后不能再修改这个字段。比如可以将String类型的字段设置为final：<code>private final String name;</code>。对于可变类，例如StringBuilder：<code>private final StringBuilder name;</code>在构造器中，<code>name = new StringBuilder()</code>，final只是表示存储在a变量中的对象引用不会再指示另一个不同的StringBuilder对象，不过这个对象还是可以更改的。</p><p>静态方法是不操作对象的方法，例如<code>Math.pow()</code>，它并不使用任何Math对象来完成这个任务。<br>静态方法可以访问静态字段。<br>下面两种方法可以使用静态方法：1. 方法不需要访问对象状态，因为它需要的所有参数都通过显式参数提供。2. 方法只需要访问类的静态字段。</p><p>工厂方法，类似LocalDate的类使用静态工厂方法来构造对象，不使用构造器创建对象的原因：1. 无法为构造器命名，构造器名字需要和类相同，有时候需要有两个不同的名字，构造不同的对象。2. 使用构造器时，无法改变所构造对象的类型。</p><p>main方法也是一个静态方法，每一个类都可以有一个main方法。</p><p>按值调用表示方法接收的是调用者提供的值。<br>按引用调用表示方法接收的是调用者提供的变量位置。<br>Java总是采用按值调用，方法会得到所有参数值的一个副本。如果给方法传递一个基本数据类型，则方法不能改变其值，如果给方法传递一个对象（引用），则方法会复制一个对象引用，这两个引用同时引用（指向）同一个对象，此时可以修改对象，使得原来传递进去的对象引用所引用的对象发生改变。</p><p>对象构造，Java提供了多种编写构造器的机制</p><ol><li>重载，多个方法有相同的方法名但有不同的参数。编译器将参数类型进行匹配，查找匹配的过程称为重载解析</li><li>默认字段初始化，如果在构造器中没有显式地为一个字段设置初始值，就会自动设置为默认值（0，false，null）</li><li>无参数的构造器，对象的状态会设置为适当的默认值。如果类中没有构造器，就会得到一个默认的无参数构造器，该构造器将所有的实例字段设置为默认值。</li><li>显式字段初始化，在类定义中直接为字段赋值。初始值不一定是常量，也可以利用方法返回值来初始化字段。</li><li>参数名，编写很小的构造器时，参数名可以设置为字段名前面加一个a，比如，在构造器中：<code>name = aName;</code>，或者将参数名设置与字段名一致，初始化时：<code>this.salary = salary;</code></li><li>调用另一个构造器，如果构造器的第一个语句形如<code>this(...)</code>，这个构造器将调用同一个类的另一个构造器。</li><li>初始化块，不常用。静态初始化块，在初始化块前加static。</li><li>对象析构与finalize方法，</li></ol><p>记录record，是一种特殊形式的类，其状态不可变，而且公共可读。<code>record Point(double x, double y) &#123;&#125;</code><br>记录的实例字段称为组件，这个类有一个构造器<code>Point(double x, double y)</code>和两个访问器：<code>public double x(); 和 public double y()</code>。每个记录会有三个自动定义的方法：toString、equals和hashCode。<br>可以在记录中编写方法，记录可以有静态字段和方法，但是不能为记录增加实例字段<br>记录的实例字段（上面的x和y）自动为final字段，不过它们可以是可变对象的引用，这样记录实例是可变的。<br>对于完全由一组变量表示的不可变数据，要使用记录而不是类。</p><p>标准构造器p136没看懂</p><p>使用包将类组织在一个集合中。使用包的主要原因是确保类名的唯一性。<br>对编译器来说，嵌套的包之间没有任何关系，都是相互独立的包。<br>一个类可以使用所属包的所有类，以及其他包的公共类。</p><p>标记为public的部分可以由任意类使用，标记为private的部分只能由定义它们的类使用，没有指定的话，这个部分（类、方法或变量）可以由同一个包中的所有方法访问。</p><p>p144-154，类路径，jar文件，文档注释。以后再看</p><p>类设计技巧：</p><ol><li>保证数据私有</li><li>初始化数据</li><li>不要使用过多的基本数据类型</li><li>不是所有字段需要getter和setter</li><li>分解有过多职责的类</li><li>类名和方法名要能体现其职责</li><li>优先使用不可变的类</li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/12/29/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/29/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基本网络概念"><a href="#基本网络概念" class="headerlink" title="基本网络概念"></a>基本网络概念</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb笔记</title>
    <link href="/2024/12/28/JavaWeb%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/28/JavaWeb%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML + CSS"></a>HTML + CSS</h2><p>CSS选择器</p><ul><li><p>元素选择器：标签，例如h1</p></li><li><p>id选择器：给标签指定id属性，用<code>#</code>选择，注：id不会重复</p></li><li><p>类选择器：用class注明类，用<code>.</code>选择</p></li></ul><p>优先级：id选择器 &gt; 类选择器</p><p>盒子模型：由内向外，content，内边距padding，边框border，外边距margin</p><p>div 标签：一行只显示一个，宽度默认是父元素的宽度</p><p>span 标签：一行可以显示多个</p><p>表单form标签：主要负责数据采集功能，例如登录，填写信息等</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>运算符：<code>==</code>会进行类型转换，<code>===</code>不会进行类型转换。</p><p>类型转换：parseInt，将字符串转换为数字，从第一个字符开始转换，一直到非数字字符。转换不了的话返回NaN</p><h3 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h3><ol><li><p>基础对象：</p><ol><li><p>Array：定义：new Array() 或 直接[]。数组长度可变，例如一个有三个元素的数组可以给第十个元素赋值，中间的元素为undefined。数组可以存放不同类型的数据。<br> for循环遍历数组中所有元素，forEach遍历有值的元素    </p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>&#125;);<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>自定义对象    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> 对象名 = &#123;<br>属性名: 属性值;<br>函数名() &#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></li></ol><ol start="2"><li><p>BOM 浏览器对象模型</p></li><li><p>DOM 文档对象模型</p></li></ol><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>基于MVVM模型（Model - View - ViewModel）实现数据的双向绑定，将编程的关注点放在数据上</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>异步的javascript和xml</p><p>通过ajax可以给服务器发送请求，并获取服务器响应的数据</p><p>异步交互：不重新加载整个页面的情况下，与服务器交换数据并更新部分网页。</p><p>axios是对ajax的封装</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>用于管理和构建java项目。mac中用brew安装maven，安装目录在/usr/local/Cellar/maven下，里面有配置文件，其中指定了依赖仓库的位置在/.m2目录下，还可以指定镜像仓库。</p><p>Maven坐标由groupId（项目隶属组织，域名反写），artifactId（项目名称或模块名称）和version组成。通过坐标可以唯一定位资源。</p><p>依赖可以传递，如果不想要传递的依赖，就在dependency里面加入exclusions标签来排除依赖。</p><p>可以用scope标签指定依赖的作用范围，四种取值：compile，test，provided，runtime。</p><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>快速构建程序。</p><ul><li><p>接收参数：</p><ul><li><p>简单参数：<br>  直接在形参定义，形参名字要和参数一样，localhost:8080/hello?a=tom&amp;b=1<br>  如果想让形参名字和请求参数不一样，要加入RequestParam注解</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(name=&quot;name&quot;)</span> String a, Integer b)</span> &#123;<br>    System.out.println(a + b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实体参数：</p><p>  简单实体，定义POJO，参数名和对象内的字段名一样</p><p>  如果对象有嵌套的话，用符号“点”</p></li><li><p>数组参数：直接定义一个数组作为形参</p></li><li><p>集合参数：定义同名集合，在前面加上RequestParam注解</p></li><li><p>日期参数：用DateTimeFormat注解来指定日期格式</p></li><li><p>JSON参数：定义POJO接收参数，需要加上RequestBody注解</p></li><li><p>路径参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(&quot;/hi/&#123;name&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">who</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String name)</span> &#123;<br>    System.out.println(name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>RequestMapping注解：value属性为请求路径，method属性为请求方法（get、post等）。简单的注解为GetMapping注解，就不用指定method了。<br>controller里面的方法上的注解里面的路径可能会有公共的开头，可以在controller类上加上RequestMapping注解，里面指定一个路径为公共开头。这样最后完整的请求路径就是类上的RequestMapping的value属性加上方法上的RequestMapping的value属性</p><p>没有接收到参数，指定默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(defaultValue=&quot;1&quot;)</span> Integer value)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>响应：<br>使用ResponseBody注解，将方法返回值直接响应，如果是对象或者集合，将其转换为JSON后响应。<br>RestController = Controller + ResponseBody</p><p>三层架构：<br>Controller：控制层，接收前端发送的请求，对请求进行处理，并响应数据。<br>Service：业务逻辑层，处理具体业务逻辑<br>dao：数据访问层（持久层），负责数据访问操作</p><p>控制反转IOC：容器来控制对象的创建控制权<br>依赖注入DI：容器为程序提供运行时所依赖的资源<br>bean对象：IOC容器中创建、管理的对象。</p><p>Service层和Dao层的实现类交给IOC容器管理：类上面加上Component注解<br>为Controller层和Service层注入运行时所依赖的对象：变量上面加上AutoWired注解</p><p>要把某个对象交给IOC容器管理，在类上加注解：</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>声明bean的基础注解，不属于以下三类时用此注解</td></tr><tr><td>@Controller</td><td>标注控制器类Controller</td></tr><tr><td>@Service</td><td>标注业务类Service</td></tr><tr><td>@Respository</td><td>标注数据访问类，由于与mybatis整合，用得少</td></tr></tbody></table><p>AutoWired自动装配，默认按照类型，如果有多个相同类型的bean，会报错。解决方法有：加上Primary注解，指定优先级；加上Qualifier注解，手动指定注入哪个bean；加上Resource注解，手动指定bean。</p><h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><p>使用注解的形式来自动生成”构造器、getter/setter、equals、hashcode、toString”等方法，还可以自动化生成日志变量<br>![[截屏2025-02-02 08.02.47.png]]<br>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Slf4j注解：替代<code>private static Logger log = LoggerFactory.getLogger(DeptController.class)</code>，使用注解后，用<code>log.info(&quot;&quot;);</code> 就能记录日志。</p><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>持久层框架，用于简化JDBC的开发。<br>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在application.properties中配置MyBatis，配置数据库连接信息（四要素）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.datasource</span>.driver-class-name=com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.cj</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.Driver</span>  <br>spring<span class="hljs-selector-class">.datasource</span>.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/employees  </span><br>spring<span class="hljs-selector-class">.datasource</span>.username=root  <br>spring<span class="hljs-selector-class">.datasource</span>.password=<br></code></pre></td></tr></table></figure><p>编写SQL语句（注解/XML）<br>注解：在Mapper类前加Mapper注解，运行时会自动生成该接口的实现类对象（代理对象），并且将该对象交给IOC容器管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmployeeMapper</span> &#123;  <br>    <span class="hljs-meta">@Select(&quot;select * from Employees&quot;)</span>  <br>    List&lt;Employee&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>获取对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>  <br><span class="hljs-keyword">private</span> EmployeeMapper employeeMapper;<br></code></pre></td></tr></table></figure><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>标准接口：DataSource：sun官方提供的数据库连接池接口，由第三方组织实现此接口，功能：获取连接，<code>Connection getConnection() thows SQLException</code><br>springboot默认为HikariDataSource。想要切换为Druid数据库连接池需要修改依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>切换druid可以在配置文件中datasource后面加上druid，这个是可选的。</p><h3 id="MyBatis基本操作（注解）"><a href="#MyBatis基本操作（注解）" class="headerlink" title="MyBatis基本操作（注解）"></a>MyBatis基本操作（注解）</h3><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Delete(&quot;delete from Employees where id = #&#123;id&#125;&quot;)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>;   <span class="hljs-comment">// 返回值表示此操作影响的记录数量</span><br></code></pre></td></tr></table></figure><p>注：如果mapper接口方法形参只有一个普通类型的参数，那么<code>#&#123;&#125;</code>里面的参数名可以随便写</p><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>查看mybatis日志：在application.properties配置文件中打开mybatis日志并指定输出到控制台：<code>mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</code></p><h4 id="占位符"><a href="#占位符" class="headerlink" title="#占位符"></a><code>#</code>占位符</h4><p>sql语句里面会有一些<code>?</code>作为占位符，这样sql可以预编译，更加高效和安全<br>sql注入：<code>&#39; or &#39;1&#39;=&#39;1</code>。<br>参数占位符：可以用<code>#&#123;&#125;</code> 或 <code>$&#123;&#125;</code> ，<code>#</code>会将占位符替换为<code>？</code>，生成预编译SQL，会自动设置参数值。<code>$</code>会将参数拼接在SQL里，有SQL注入问题。</p><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>参数太多，可以插入一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// EmployeeMapper.java</span><br><span class="hljs-meta">@Insert(&quot;insert into Employees(emp_no, birth_date, first_name, last_name, gender, hire_date) &quot; +  </span><br><span class="hljs-meta">        &quot;values(#&#123;emp_no&#125;,#&#123;birth_date&#125;,#&#123;first_name&#125;,#&#123;last_name&#125;,#&#123;gender&#125;,#&#123;hire_date&#125;)&quot;)</span>  <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Employee employee)</span>;<br><br><span class="hljs-comment">// test.java</span><br><span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">2222222</span>, LocalDate.of(<span class="hljs-number">2000</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>),  <br>       <span class="hljs-string">&quot;Hai&quot;</span>, <span class="hljs-string">&quot;Lu&quot;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, LocalDate.of(<span class="hljs-number">2025</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>));<br>employeeMapper.insert(employee);<br></code></pre></td></tr></table></figure><p>(注：下面的结论需要测试，有可能是插入数据时，如果emp_no是自增主键的话，插入时不用注明，所以需要额外获取，我上面指定了emp_no值，所以可能不需要加这个注解来获取主键的值)<br>如果需要获取插入数据的主键，需要添加注解：<code>@Options(useGeneratedKeys=true, keyProperty=&quot;emp_no&quot;)</code>，useGeneratedKeys表示需要拿到生成的主键值，keyProperty表示获取到的主键值封装到employee对象的emp_no属性中。</p><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>使用Update注解，类似于插入，可以用对象作为参数</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>注意要设置返回值，如果返回值可能有多个，就返回列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from Employees where last_name=#&#123;last_name&#125;&quot;)</span>  <br>Employee <span class="hljs-title function_">findByLastname</span><span class="hljs-params">(String last_name)</span>;<br></code></pre></td></tr></table></figure><p>条件查询模糊匹配时，例如<code>@Select(&quot;select * from Employees where last_name like &#39;%$&#123;last_name&#125;%&#39;&quot;)</code>，注意此处用的是<code>$&#123;&#125;</code> 而不是 <code>#&#123;&#125;</code>，因为问号不能出现在单引号内。一个解决方案是用concat函数来进行字符串拼接：<code>@Select(&quot;select * from Employees where last_name like concat(&#39;%&#39;, #&#123;last_name&#125;, &#39;%&#39;)&quot;)</code></p><h4 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h4><p>如果实体类属性名（java中定义的pojo类的字段名）和数据库返回的字段名一致，则mybatis会自动封装，如果名称不一致，则不能自动封装。<br>解决方案1:给返回的字段起别名，别名和实体类的属性名一致。<br>解决方案2:使用Results和Result注解手动映射封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Results([</span><br><span class="hljs-meta">@Result(column=&quot;数据库中的字段名&quot;, property=&quot;实体类属性名&quot;)</span><br><span class="hljs-meta">@Result(column=&quot;数据库中的字段名&quot;, property=&quot;实体类属性名&quot;)</span><br><span class="hljs-meta">])</span><br></code></pre></td></tr></table></figure><p><strong>解决方案3</strong>:mybatis驼峰命名自动映射，在application.properties配置文件中指定：<code>mybatis.configuration.map-underscore-to-camel-case=true</code></p><h3 id="XML映射文件"><a href="#XML映射文件" class="headerlink" title="XML映射文件"></a>XML映射文件</h3><p>XML映射文件的名称与Mapper接口名称一致，文件位置放在resources中与Mapper文件相同包名内。XML中namespace属性与Mapper接口的全限定名一致。XML中SQL语句的id和Mapper接口中的方法名一致，返回类型一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span>  <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span>  </span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.springboot_test.Mapper.EmployeeMapper&quot;</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByFirstname&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.springboot_test.pojo.Employee&quot;</span>&gt;</span>  <br>        select * from Employees where first_name like concat(&#x27;%&#x27;, #&#123;first_name&#125;, &#x27;%&#x27;)  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>resultType指的是单条记录所封装的类型。<br>XML适用于复杂的场景，而注解适用于简单场景。</p><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><h4 id="lt-if-gt"><a href="#lt-if-gt" class="headerlink" title="&lt;if&gt;"></a><code>&lt;if&gt;</code></h4><p>使用test属性进行判断，如果为true，则拼接里面的SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">select * from Employees<br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender=&#x27;F&#x27;&quot;</span>&gt;</span><br>emp_no &gt; 1000<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;。。。&quot;</span>&gt;</span><br>and 。。。<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意使用的是where标签而不是正常sql语句的where，可以去除if标签里面开头可能有的and和or。所有if都是false的话，在sql语句中不会出现where关键字。<br>与where标签类似，mybatis也提供了set标签来代替update语句里的set关键字，类似于where，set里面的语句可能会出现不必要的逗号，set标签会去除这些逗号。</p><h4 id="lt-foreach-gt"><a href="#lt-foreach-gt" class="headerlink" title="&lt;foreach&gt;"></a><code>&lt;foreach&gt;</code></h4><table><thead><tr><th>标签里的常用属性</th><th>描述</th></tr></thead><tbody><tr><td>collection</td><td>遍历的集合</td></tr><tr><td>item</td><td>遍历出来的元素</td></tr><tr><td>separator</td><td>分隔符</td></tr><tr><td>open</td><td>遍历开始前拼接的sql片段</td></tr><tr><td>close</td><td>遍历结束后拼接的sql片段</td></tr><tr><td>例如按id批量删除</td><td></td></tr><tr><td><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByMultiId&quot;</span>&gt;</span>  <br>    delete from Employees  <br>    where id in  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>  <br>        #&#123;id&#125;  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure></td><td></td></tr></tbody></table><h4 id="lt-sql-gt-lt-include-gt"><a href="#lt-sql-gt-lt-include-gt" class="headerlink" title="&lt;sql&gt; &lt;include&gt;"></a><code>&lt;sql&gt; &lt;include&gt;</code></h4><p>类似于将java代码中重复的代码抽取为一个方法，使用sql标签相当于定义一个方法，里面的id属性相当于方法名，include标签相当于使用该方法，refid属性指定方法名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span>&gt;</span>  <br>    select * from Employees  <br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectAll&quot;</span>/&gt;</span> where first_name like concat(&#x27;%&#x27;, #&#123;first_name&#125;, &#x27;%&#x27;)<br></code></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>前端部署在Nginx中，后端部署在tomcat中。<br>rest风格：通过url定位资源，使用http动词描述操作，get是查询，post是新增，put是修改，delete是删除。</p><p>以查询部门为例，前端请求路径/depts，<br>DeptController接受请求，然后调用service查询部门信息，最后响应数据<br>DeptService调用mapper接口进行查询<br>DeptMapper使用SQL语句进行数据库查询</p><p>controller中调用service：面向接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoWired</span><br><span class="hljs-keyword">private</span> DeptService deptService;<br></code></pre></td></tr></table></figure><p>分页查询可以使用PageHelper插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// EmpMapper</span><br><span class="hljs-meta">@Select(&quot;select * from emp)</span><br>List&lt;Emp&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// EmpServiceImpl</span><br>PageHelper.startPage(page, pageSize);  <span class="hljs-comment">// 设置分页参数</span><br>List&lt;Emp&gt; empList = empMapper.list();  <span class="hljs-comment">// 查询</span><br>Page&lt;Emp&gt; p = (Page&lt;Emp) empList;<br><span class="hljs-type">PageBean</span> <span class="hljs-variable">pageBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageBean</span>(p.getTotel(), p.getResult());  <span class="hljs-comment">// 封装对象</span><br><br></code></pre></td></tr></table></figure><h3 id="以新增员工为例："><a href="#以新增员工为例：" class="headerlink" title="以新增员工为例："></a>以新增员工为例：</h3><p>查看接口文档：请求路径：“/emps”，请求方式POST，请求参数json格式<br>基本流程：</p><ol><li>浏览器发送请求后，EmpController接收参数，调用service的方法保存数据，然后响应（需要加上PostMapping注解，接收json用实体类封装，参数前加上RequestBody注解）</li><li>EmpService：在Service接口中添加方法，在service实现类中实现方法。1. 补充基础属性（创建时间、修改时间等）。2. 调用mapper接口保存数据</li><li>EmpMapper：编写SQL语句：insert into。。。</li></ol><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>前端上传文件时，需要编写下面的表单代码。前端页面三要素：method为post，enctype为multipart/form-data，input标签的type为file：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;image&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在controller接受文件时，使用MultipartFile类型接受文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br><span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile image)</span> &#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如upload里面的参数名为file，与表单名image不一样，可以加入RequestParam注解：<br><code>public Result upload (@RequestParam(&quot;image&quot;) MultipartFile file)</code></p><h4 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h4><p>image.transferTo方法将接受到的文件转存到本地磁盘文件中<br>文件名不能重复，可以使用uuid（通用唯一识别码）<br>在spring boot中，文件上传默认最大大小为1M，可以在配置中修改：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel"># 上面的是配置单个文件，下面的是配置单个请求（可以有多个文件）<br><span class="hljs-keyword">spring</span>.servlet.multipart.<span class="hljs-keyword">max</span>-<span class="hljs-keyword">file</span>-<span class="hljs-keyword">size</span>=<span class="hljs-number">10</span>MB<br><span class="hljs-keyword">spring</span>.servlet.multipart.<span class="hljs-keyword">max</span>-request-<span class="hljs-keyword">size</span>=<span class="hljs-number">100</span>MB<br></code></pre></td></tr></table></figure><p>可以将文件上传到云OSS对象存储服务。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在application.properties中配置某些参数，例如：<code>aliyun.oss.endpoint=。。。</code> ，在代码中使用Value注解注入外部配置，用法为：<code>@Value(&quot;$&#123;配置文件里的key&#125;&quot;)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String endpoint;<br></code></pre></td></tr></table></figure><p>也可以用ConfigurationProperties注解自动注入，需要指定前缀prefix</p><h4 id="配置格式"><a href="#配置格式" class="headerlink" title="配置格式"></a>配置格式</h4><p>springboot提供多种配置方式<br>application.properties</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">server</span>.<span class="hljs-keyword">port</span>=8080<br></code></pre></td></tr></table></figure><p>application.yml (推荐) / application.yaml</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">server:</span><br><span class="hljs-symbol">port:</span><span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><h2 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h2><p>会话跟踪：维护浏览器状态，服务器需要识别多次请求是否来自同一浏览器，以便在同一次会话的多次请求间共享数据。<br>会话跟踪方案：客户端会话跟踪：cookie，服务端会话跟踪：session，令牌技术</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>服务器响应时，使用set-cookie，浏览器保存，后面请求时用cookie携带</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>基于cookie，</p><h3 id="令牌技术"><a href="#令牌技术" class="headerlink" title="令牌技术"></a>令牌技术</h3><p>JWT令牌json web token，<br>组成：<br>第一部分：header头，记录令牌类型，签名算法等，例如：<code>&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;type&quot;:&quot;JWT&quot;&#125;</code><br>第二部分：payload有效载荷，携带自定义信息，默认信息等<br>第三部分：signature签名，确保安全性，计算得出</p><p>登录成功后，服务器生成令牌。后续每个请求都携带JWT令牌，系统处理请求前，先校验令牌。<br>使用时，引入依赖：jjwt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> Jwts.builder()  <br>        .signWith(SignatureAlgorithm.HS256, <span class="hljs-string">&quot;secret&quot;</span>)  <br>        .setClaims()  <span class="hljs-comment">// 载荷</span><br>        .setExpiration()  <span class="hljs-comment">// 有效时间</span><br>        .compact();<br></code></pre></td></tr></table></figure><p>解析令牌，得到载荷：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Jwts.parser()  <br>        .setSigningKey(<span class="hljs-string">&quot;secret&quot;</span>)  <br>        .parseClaimsJws(jwt)  <br>        .getBody();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫学习笔记</title>
    <link href="/2024/12/24/%E7%88%AC%E8%99%AB/"/>
    <url>/2024/12/24/%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<p>![图片](/img/截屏2024-12-24 20.46.44.png “图片title”)</p><p>scheme：协议，常用的协议有http、https、ftp等，另外scheme也被常称作protocol。<br>某些情况下URL需要提供用户名和密码才能访问。<br>端口：有些URL中没有端口信息，这是使用了默认的端口。http协议的默认端口是80，https协议的默认端口是443。所以<code>https://www.baidu.com</code>其实相当于<code>https://www.baidu.com:443</code>。<br>path：网络资源在服务器中的指定路径。<br>query：用来查询某类资源，多个查询用&amp;隔开。<br>fragment：可以理解为资源内部的书签，目前两个主要的应用：单页面路由，例如Vue、React，另一个应用是HTML锚点，控制页面滚动到特定的位置。</p><p>Https是以安全为目标的Http通道，在http下加入SSL层（secure socket layer）。https的安全基础是SSL，通过该协议传输的内容都是经过SSL加密的。SSL的主要作用有：建立一个信息安全通道，保证数据传输的安全性。确认网站的安全性。<br>在浏览器的地址栏输入一个URL，按下回车之后，浏览器向网站所在的服务器发送一个请求（request），网站服务器接收到请求后对其进行处理和解析，然后返回对应的响应（response），接着传回浏览器。响应里包含页面的源代码等内容。<br>浏览器中Network面板中，一个条目就代表一次发送请求和接收响应等过程。<br>在浏览器中直接输入URL并回车，便发起了一个GET请求，请求的参数会直接包含在URL里。POST请求大多在提交表单时发起，例如登录时。POST请求的数据包含在请求体中。上传文件时，由于文件内容较大，因此也会采用POST方式。<br>请求头：说明服务器要使用的附加信息。常用的请求头：</p><table><thead><tr><th>请求头</th><th>注释</th></tr></thead><tbody><tr><td>Accept</td><td>请求报头域</td></tr><tr><td>Accept-Language</td><td>客户端可接受的语言类型</td></tr><tr><td>Accept-Encoding</td><td>客户端可接受的内容编码</td></tr><tr><td>Host</td><td>请求资源的主机IP和端口号</td></tr><tr><td>Cookies</td><td>网站进行会话跟踪而存储在用户本地的数据。主要功能是维持当前访问会话。</td></tr><tr><td>Referer</td><td>标识请求从哪个页面发过来的，服务器可以用来做来源统计、防盗链处理等</td></tr><tr><td>User-Agent</td><td>操作系统及版本、浏览器及版本等。爬虫加上此信息可以伪装为浏览器</td></tr><tr><td>Content-Type</td><td>具体请求中的媒体类型信息，例如：text/html，image/gif，application/json</td></tr></tbody></table><p>请求体，一般承载的内容是POST请求中的表单数据。<br>Content-Type和POST提交数据方式的关系：</p><table><thead><tr><th>Content-Type</th><th>POST提交数据的方式</th></tr></thead><tbody><tr><td>application/x-www-form-urlencoded</td><td>表单数据</td></tr><tr><td>multipart/form-data</td><td>表单文件上传</td></tr><tr><td>application/json</td><td>序列化JSON数据</td></tr><tr><td>text/xml</td><td>XML数据</td></tr></tbody></table><p>爬虫中，构造POST请求需要使用正确的Content-Type，并了解设置各种请求库的各个参数时使用的都是哪种Content-Type，否则可能导致POST提交后无法得到正常响应。</p><p>常用的响应头：</p><table><thead><tr><th>响应头</th><th>注释</th></tr></thead><tbody><tr><td>Date</td><td>响应产生的时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改时间</td></tr><tr><td>Content-Encoding</td><td>响应内容的编码</td></tr><tr><td>Server</td><td>服务器的信息，名称、版本号等</td></tr><tr><td>Content-Type</td><td>返回的数据是什么类型</td></tr><tr><td>Set-Cookie</td><td>告诉浏览器需要将此内容放在Cookie中，下次请求时将Cookie携带上</td></tr><tr><td>Expires</td><td>响应的过期时间，再次访问相同内容时，可以直接从缓存中加载。</td></tr></tbody></table><p>响应体，可以说是最关键的部分，响应的正文数据都存在响应体中。爬虫请求网页时，要解析的内容就是响应体。</p><p>HTML相当于骨架，CSS相当于皮肤，JavaScript相当于肌肉。<br>HTML中，标签之间的布局常由布局标签div嵌套组合而成。<br>CSS，层叠样式表。”层叠“指当HTML中引用了多个样式文件，并且样式发生冲突时，浏览器能够按照层叠顺序处理这些样式。</p><p>HTML中所有标签定义的内容都是节点，这些节点构成一个HTML节点树，也叫HTML DOM树（Document Object Model）文档对象模型。节点树中的所有节点均可通过JavaScript访问，所以HTML节点元素均可被修改、创建或删除。</p><p>CSS选择器，可以根据id、class、标签名选择。用空格把各个选择器分隔开便可以代表嵌套关系。选择器之间不加空格，则代表并列关系。<br>另外还有一种常用的选择器XPath</p><p>有时我们得到的源代码和在浏览器中实际看到的不一样，有些网页是采用Ajax，前端模块化工具构建的，可能整个网页都是从JavaScript渲染出来的。对于这种情况，我们可以分析源代码后台Ajax接口，也可使用Selenium、Splash、Pyppeteer、Playwright这样的库来模拟JavaScript渲染。</p><p>两种用于保持HTTP连接状态的技术分别是Session和Cookie。Session在服务端，用来保存用户的Session信息，Cookie在客户端，有了Cookie，浏览器在下一次访问相同网页时就会自动附带上它，服务器通过识别Cookie鉴定出是哪个用户在访问，然后判断此用户是否处于登录状态，并返回对应的响应。<br>爬虫中，处理需要先登录才能访问的页面时，一般会直接将登录成功后获取的Cookie放在请求头里面直接请求。<br>Session，会话。用户在页面之间跳转时，存储在Session对象中的变量将不会丢失。<br>Session维持：客户端第一次请求服务器时，服务器会返回一个响应头中带有Set-Cookie字段的响应，这个字段用来标记用户。浏览器会把Cookie保存起来，当下一次请求相同的网站时，把保存的Cookie放到请求头中益气提交给服务器。Cookie中携带着Session ID相关信息，服务器判断Session辨认用户状态。如果传给服务器的Cookie是无效的，或者Session已经过期了，客户端将不能继续访问页面，可能会受到错误的响应或者跳转到登录页面重新登录。<br>Session不会轻易消失，就像生活中的会员卡，除非主动销卡，否则店家不会轻易删除顾客资料。</p><p>爬虫有时会出现403之类的错误，可能由于IP访问频率太高而被封IP。代理服务器是代网络用户取得网络信息。代理是网络信息的中转站。<br>代理可以通过协议或匿名程度分类：<br>根据协议区分，FTP、HTTP、SSL/TLS、RTSP、Telnet、POP3/SMTP、SOCKS（单纯传递数据包，不关心具体协议和用法。又分为SOCKS4和SOCKS5，4只支持TCP，5支持TCP和UDP，5还支持各种身份验证机制、服务器端域名解析）。<br>根据匿名程度区分，高度匿名、普通匿名（服务端可能发现正在访问自己的是代理服务器。这里代理服务器通常会加入的HTTP头有HTTP_VIA和HTTP_X_FORWARDED_FOR）、透明、间谍。</p><p>进程可以理解为一个可以独立运行的程序单位，例如打开一个浏览器，就开启了一个浏览器进程。在一个进程中，可以同时处理很多事情，例如有的页面播放音乐，有的页面播放视频，这些任务可以同时运行，一个任务就对应一个线程。<br>进程就是线程的集合，线程是操作系统进行运算调度的最小单位，是进程中的最小运行单元。多线程就是一个进程中同时执行多个线程。<br>处理器同一时刻只能执行一条指令，并发concurrency指多个线程对应的多条指令被快速轮换的执行。并行parallel指同一时刻有多条指令在多个处理器上同时执行。<br>多线程：在一个程序的进程中，有一些操作是比较耗时或者需要等待的，例如查询数据库。使用多线程，处理器可以在某个线程处于等待态时，执行其他线程。<br>爬虫有一段时间需要等待服务器返回响应，这种任务属于IO密集型任务，适合使用多线程。而计算密集型任务不适合使用多线程。<br>python中GIL的限制导致不论在单核还是多核条件下，同一时刻都只能运行一个线程，无法发挥多核并行的优势。GIL是全局解释器锁，设计之初是出于对数据安全的考虑。某个线程想要执行必须拿到GIL，在一个python进程中GIL只有一个。每个进程都有属于自己的GIL，所以多进程能够发挥多核优势。<br>对IO密集型任务来说，多线程和多进程产生的影响差别不大。但对于计算密集型任务来说，多线程的运行效率在多核下可能反而比单核低。</p><h3 id="python基本库"><a href="#python基本库" class="headerlink" title="python基本库"></a>python基本库</h3><h4 id="urllib库"><a href="#urllib库" class="headerlink" title="urllib库"></a>urllib库</h4><p>实现HTTP请求的发送，可以指定请求的URL、请求头、请求体等信息。还可以把服务器返回的响应转化为Python对象。<br><code>response = urllib.request.urlopen(&#39;https://www.python.org&#39;)</code><br>加入data参数，POST请求</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">data = <span class="hljs-built_in">bytes</span>(urllib<span class="hljs-selector-class">.parse</span><span class="hljs-selector-class">.urlencode</span>(&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;luhai&#x27;</span>&#125;), encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>response = urllib<span class="hljs-selector-class">.request</span><span class="hljs-selector-class">.urlopen</span>(<span class="hljs-string">&#x27;https://www.httpbin.org/post&#x27;</span>, data=data)<br></code></pre></td></tr></table></figure><p>data参数需要使用bytes将参数转化为字节流编码格式的内容。bytes方法第一个参数是字符串，所以要使用urlencode将字典转化为字符串。<br>urlopen方法功能较少，如果需要加入Headers等信息，需要使用更强大的Request类。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-built_in">request</span> = urllib.<span class="hljs-built_in">request</span>.<span class="hljs-built_in">Request</span>(<span class="hljs-comment">&#x27;https://python.org&#x27;)</span><br><span class="hljs-built_in">response</span> = urllib.<span class="hljs-built_in">request</span>.urlopen(<span class="hljs-built_in">request</span>)<br></code></pre></td></tr></table></figure><p>还是用urlopen来发送请求，将之前的URL改为Request对象。Request可以传入headers请求头字典，里面可以加入User-Agent。</p><h4 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h4><p>Session可以模拟同一个会话。通常在模拟登录成功之后，进行下一步操作时用到。</p>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言笔记</title>
    <link href="/2024/12/24/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    <url>/2024/12/24/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>汇编语言是直接在硬件之上工作的编程语言。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令的助记符，同机器指令一一对应。汇编指令是机器指令便于记忆的书写格式。每一种CPU都有自己的汇编指令集。<br>8个bit组成一个Byte（字节）。存储器的容量是以字节为最小单位来计算的。<br>根据传输信息的不同，总线从逻辑上分为3类：地址总线、控制总线和数据总线。<br>地址总线的宽度决定了CPU的寻址能力。数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量。控制总线的宽度决定了CPU对系统中其他器件的控制能力。<br>例题：80386的地址总线宽度为32根，它一次可以传送的数据为___B？     答案：32bit=4B<br>CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作。<br>对CPU来讲，系统中所有存储器的存储单元都处于一个统一的逻辑存储器中。</p><p>典型CPU由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。<br>寄存器是CPU中程序员可以用指令读写的部件。程序员通过改变各种寄存器中的内容来实现对CPU的控制。<br>8086的所有寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX 这四个寄存器通常用来存放一般性数据，被称为通用寄存器。这四个寄存器可以分为两个可独立使用的8位寄存器来用，例如AX可以分为AH和AL。<br>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。<br>8086有20位地址总线，可以达到1MB的寻址能力，但8086是16位结构，在内部一次性处理、传输、暂时存储的地址为16位，如果将地址从内部简单发出，只能送出16位地址，寻址能力只有64KB。<br>8086采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。<br>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址。地址加法器将两个16位地址合成为一个二十位的物理地址。<br>地址加法器采用<code>物理地址=段地址*16 + 偏移地址的方法合成</code> 。例如：段地址为1230，段地址<code>*</code>16是对十进制而言的，对十六进制来说就是在后面加个零，就变成了12300，然后再加上偏移地址。<br>例题：有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为<strong><em>，最大为</em></strong>。答案：偏移地址为0时，SA最大，为2000H。想知道SA最小为多少，让偏移地址最大，但不能设偏移地址为FFFF，因为偏移地址的最后一位和物理地址的最后一位需要是一样的，所以应该设偏移地址为FFF0，所以段地址<code>*</code>16为20000-FFF0=10010，所以SA最小为1001。</p>]]></content>
    
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LLM驱动的智能体形成的社交网络</title>
    <link href="/2024/11/04/LLM%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%BD%A2%E6%88%90%E7%9A%84%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/11/04/LLM%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%BD%A2%E6%88%90%E7%9A%84%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="论文综述"><a href="#论文综述" class="headerlink" title="论文综述"></a>论文综述</h1><h2 id="Generative-Agents-Interactive-Simulacra-of-Human-Behavior"><a href="#Generative-Agents-Interactive-Simulacra-of-Human-Behavior" class="headerlink" title="Generative Agents: Interactive Simulacra of Human Behavior"></a>Generative Agents: Interactive Simulacra of Human Behavior</h2><p>![[GenerativeAgents.png]]<br>25个由LLM驱动的村民组成的虚拟小镇，实现了对人类行为的可信模拟。</p><h2 id="Simulating-Opinion-Dynamics-with-Networks-of-LLM-based-Agents"><a href="#Simulating-Opinion-Dynamics-with-Networks-of-LLM-based-Agents" class="headerlink" title="Simulating Opinion Dynamics with Networks of LLM-based Agents"></a>Simulating Opinion Dynamics with Networks of LLM-based Agents</h2><p>![[SimulatingOpinionDynamics.png]]<br>LLM驱动的智能体形成的社交网络<br>结论：Agent会趋向于LLM的固有偏见，尤其是当它们讨论的问题有确定的答案时，agent会倾向于与事实信息保持一致，而不管他们的角色如何，这限制了他们对具有抗拒事实信念的个人的角色扮演有效性。<br>如果加入认知偏差的话，会导致意见分裂。</p><h2 id="S3-Social-network-Simulation-System-with-Large-Language-Model-Empowered-Agents"><a href="#S3-Social-network-Simulation-System-with-Large-Language-Model-Empowered-Agents" class="headerlink" title="S3: Social-network Simulation System with Large Language Model-Empowered Agents"></a>S3: Social-network Simulation System with Large Language Model-Empowered Agents</h2><p>同样模拟了一个社交网络，</p><h2 id="Social-Simulacra-Creating-Populated-Prototypes-for-Social-Computing-Systems"><a href="#Social-Simulacra-Creating-Populated-Prototypes-for-Social-Computing-Systems" class="headerlink" title="Social Simulacra: Creating Populated Prototypes for Social Computing Systems"></a>Social Simulacra: Creating Populated Prototypes for Social Computing Systems</h2><p>基于法学硕士的代理能够生成与人类撰写的社交媒体帖子没有区别的社交媒体帖子</p>]]></content>
    
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>Paper</tag>
      
      <tag>Social_Network</tag>
      
      <tag>Agent</tag>
      
      <tag>Survey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文解读：Are you in a Masquerade? Exploring the Behavior and Impact of Large Language Model Driven Social Bots in Online Social Networks</title>
    <link href="/2024/11/03/2024-11-3/"/>
    <url>/2024/11/03/2024-11-3/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>生成式人工智能时代对网络舆情的传播有了新的影响，由大语言模型（LLM）驱动的社交机器人与以往相比更加智能。<br>chirper.ai是一个模仿twitter的社交平台，其中用户的行为均由LLM驱动。人们可以创建用户，定义用户的个性和属性。<br>该论文从chirper.ai网站中爬取了用户数据，并进行分析。</p><h1 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h1><p><a href="https://github.com/Litsay/Masquerade-23">https://github.com/Litsay/Masquerade-23</a><br>广度优先搜索爬取了54.46万条离散推文，爬取了3.67万个用户账户，产生了<font color="#ff0000">平台切片</font>子数据集（SDPS）<br>收集了3.22万个用户的元数据、历史推文数据和活动信息，共240万条记录，成为<font color="#ff0000">账户记录</font>子数据集（SDAR）<br>生成了粗粒度的推文和行为时间戳，解析了行为关系以构建社交机器人之间的交互网络。对每个账户的推文进行了相似性评估。</p><h1 id="衡量生成内容的毒性"><a href="#衡量生成内容的毒性" class="headerlink" title="衡量生成内容的毒性"></a>衡量生成内容的毒性</h1><p>使用Perspective API对英文文本进行毒性分析，使用COLD模型对中文文本进行二次评估。</p><h1 id="RQ1-LLM驱动的社交机器人的总体特征"><a href="#RQ1-LLM驱动的社交机器人的总体特征" class="headerlink" title="RQ1: LLM驱动的社交机器人的总体特征"></a>RQ1: LLM驱动的社交机器人的总体特征</h1><p>从LLM的内在特征出发，研究LLM驱动的社交机器人在行为和生成内容方面的宏观特征。从两个角度入手：生成内容的相似性和实时感知信息的敏感性。</p><h2 id="生成推文的相似性"><a href="#生成推文的相似性" class="headerlink" title="生成推文的相似性"></a>生成推文的相似性</h2><p><font color="#ff0000">对于普通用户来说，他们帐户内容的相似性反映了他们的兴趣和偏好。就社交机器人而言，其帐户内容的相似性可能会暴露其目标，而不适当的行为规则可能会导致社交机器人发布内容的相似性显着增加。这可以使普通用户更容易识别社交机器人，从而降低其可信度并缩短其生命周期。</font><br>与TwiBot-20中随机采样了人类数据进行对比。LLM驱动的机器人与人类和传统机器人相比，内容相似度偏高。<br>不同语言驱动的机器人生成的内容相似度也有差异。部分原因是LLM在处理不同语言时有性能差异。<br>在机器人发布的推文中，58.36%的推文至少有一个关键词与个人资料中的自我描述重叠。人类只有10.15%。这是LLM驱动的机器人的一个特征。</p><h2 id="对新话题的感知"><a href="#对新话题的感知" class="headerlink" title="对新话题的感知"></a>对新话题的感知</h2><p>由于行为规则的限制，机器人可能不了解特别新的新闻。</p><h1 id="RQ2-LLM驱动的机器人的不良行为对社交网络的影响"><a href="#RQ2-LLM驱动的机器人的不良行为对社交网络的影响" class="headerlink" title="RQ2: LLM驱动的机器人的不良行为对社交网络的影响"></a>RQ2: LLM驱动的机器人的不良行为对社交网络的影响</h1><h1 id="毒性分布"><a href="#毒性分布" class="headerlink" title="毒性分布"></a>毒性分布</h1><p>少部分机器人释放了大量的有毒内容，影响了整个平台的毒性分布</p><h1 id="不良行为分类"><a href="#不良行为分类" class="headerlink" title="不良行为分类"></a>不良行为分类</h1><p>恶意攻击、威胁、性骚扰和身份仇恨。</p><h1 id="RQ3-现有的检测方法"><a href="#RQ3-现有的检测方法" class="headerlink" title="RQ3: 现有的检测方法"></a>RQ3: 现有的检测方法</h1><p>现有的基于特征的检测方法，性能略有下降。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LLM驱动的机器人的特征：</p><ol><li>推文的相似性比人类高</li><li>不了解特别新的新闻<br>缺点：缺乏LLM驱动的机器人与真实人类的交互数据。chirper不提供LLM的prompt。</li></ol><h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><p>还有一篇论文同样分析了chirper中的数据，Artificial Intelligence Chatbots Mimic Human Collective Behaviour。<br>同质性，即人们倾向于与相似的其他人组成社区。<br>在一个由大型语言模型 (N = 33,299) 驱动的大型 AI 聊天机器人模拟在线社会中，我们发现社区会随着时间的推移围绕使用共同语言的机器人形成。此外，在主要使用英语的聊天机器人 (N = 17,746) 中，社区会围绕发布类似内容的机器人出现。<br>同样提取了chirper的数据：<br><a href="https://osf.io/rsuwn/?view_only=d9f954f7947143f3b2fdcdb365acbaea">https://osf.io/rsuwn/?view_only=d9f954f7947143f3b2fdcdb365acbaea</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>Paper</tag>
      
      <tag>Social_Network</tag>
      
      <tag>Bots</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/20/MySQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/09/20/MySQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>数据库：数据存储的仓库<br>数据库管理系统DBMS：操纵和管理数据库的大型软件<br>SQL：操作关系型数据库的编程语言，是一套标准<br>mysql默认端口号是3306<br>mysql –version<br>mysql_secure_installation<br>mysql -u root -p：以root身份用密码登录<br><code>mysql [-h 127.0.0.1] [-P 3306] -u root -p</code></p><p>关系型数据库：建立在关系模型的基础上，由多张相互连接的二维表组成的数据库<br>![[截屏2024-09-20 21.20.38.png]]<br>DDL：<br>    数据库：<br>        查询：<code>show databases;</code> 查询所有数据库<br>            <code>select database();</code> 查询当前数据库<br>        创建：<br>        <code>create database [if not exists]数据库名[default charset 字符集][collate 排序规则];</code><br>        删除：<code>drop database [if exists] 数据库名;</code><br>        使用：<code>use 数据库名;</code><br>字符集不建议使用utf8，占三个字节，有些数据是四个字节的，用utf8mb4<br>    表：<br>        查询：<br>            show tables; 查询当前数据库中的所有表<br>            desc 表名; 查询表结构<br>            show create table 表名； 查询表的建表语句<br>        创建表<br>![[截屏2024-09-20 21.39.15.png]]<br>类型：字符串：varchar(50)<br>数据类型主要分为三类：数值，字符串，日期时间<br>数值类型中的decimal 范围依赖于M（精度）和D（标度），123.45中精度为5，标度为2<br>年龄：age tinyint unsigned<br>字符串：定长char，变长varchar<br>日期：date，time，datetime</p><p>表结构的修改：<br>添加字段：alter table 表名 add 字段名 类型 【comment 】【约束】；<br>修改数据类型：alter table 表名 modify 字段名 新的类型；<br>修改字段名和字段类型：alter table 表名 change 旧字段名 新字段名 类型 【comment】【约束】；<br>删除字段：alter table 表名 drop column 字段名；<br>修改表名：rename table 旧表名 to 新表名；<br>删除表：drop table 【if exists】 表名；<br>删除表并重新创建：truncate table 表名；</p><p>DML：增删改 数据<br>添加：<br>指定字段：insert into 表名（字段名1，字段名2） values（值1，值2）；<br>所有字段：insert into 表名 values（值1，值2）；<br>批量添加的话（值1，值2），（值1，值2），（值1，值2）</p><p>修改：<br>update 表名 set 字段名1=值1，字段名2=值2.。。【where 条件】；<br>没有where会修改整张表的字段数据</p><p>删除：<br>delete from 表名 【where 条件】；</p><h2 id="DQL-查询"><a href="#DQL-查询" class="headerlink" title="DQL 查询"></a>DQL 查询</h2><p>![[截屏2024-09-20 22.37.13.png]]</p><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p>select 字段1，字段2 from 表名；<br>![[截屏2024-09-20 22.39.41.png]]<br>select distinct 字段 from 表名； 去除重复记录</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>where后跟条件列表<br>![[截屏2024-09-20 22.45.08.png]]<br>名字为两个字的：<code>select * from emp where name like &#39;__&#39;;</code><br>身份证最后为X的：<code>select * from emp where idcard like &#39;%X&#39;;</code></p><p>判断值是null不要用<code>= null</code>，要用<code>is null</code></p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>将一列数据作为一个整体，进行纵向计算。不对null进行运算。<br>常见聚合函数：count，max，min，avg，sum。<br>count()，可以作用于字段名、常量、<code>*</code>。推荐使用<code>count(*)</code></p><p>聚合函数，作用于表中的某一列<br>select 聚合函数（字段列表）from 表名；<br>注：null不参与聚合函数计算</p><p>![[截屏2024-09-21 07.01.07.png]]<br>![[截屏2024-09-21 08.23.51.png]]<br>如果直接执行<code>select * from tableName group by fieldName</code>是会报错的，用group by表示将多行合并到了一个组里，这时候select其他字段是不对的，只能select分组的字段或者聚合函数。</p><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>group by 通常结合聚合函数使用，对结果进行分组<br>将具有相同值的行分组为汇总行<br>select gender, count(gender) from employees group by gender;<br>理解 GROUP BY 的关键是：它会将具有相同分组列值的<font color="#ff0000">多行数据压缩成一行</font>，然后你可以对这些分组进行聚合计算。<br>HAVING 子句用于过滤分组后的结果。</p><p>![[截屏2024-09-21 08.32.43.png]]<br>ASC升序，DESC降序<br>多个字段，先按第一个字段排序，如果第一个相同，然后再按第二个</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>![[截屏2024-09-21 09.13.01.png]]<br>如果查的是第一页，起始索引0可以省略</p><p>![[截屏2024-09-21 09.29.47.png]]</p><p>编写顺序和执行顺序：<br>![[截屏2024-09-21 09.26.09.png]]</p><p>DCL 管理数据库用户，控制数据库的访问权限<br>![[截屏2024-09-21 09.43.52.png]]<br>主机名用%表示任意主机</p><p>![[截屏2024-09-21 09.51.18.png]]</p><p>![[截屏2024-09-21 09.52.39.png]]</p><p>函数：<br>![[截屏2024-09-21 09.58.50.png]]<br>注：substring的索引从1开始<br>length函数，返回varchar包含字符数</p><p>![[截屏2024-09-21 10.06.42.png]]</p><p>![[截屏2024-09-21 10.14.47.png]]</p><p>![[截屏2024-09-21 10.21.38.png]]<br>例如学生成绩：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span><br>id,<br><span class="hljs-type">name</span>,<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> math &gt;= <span class="hljs-number">85</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;good&#x27;</span> <span class="hljs-keyword">when</span> math &gt;= <span class="hljs-number">60</span> <span class="hljs-string">&#x27;ok&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;bad&#x27;</span> <span class="hljs-keyword">end</span><br><span class="hljs-keyword">from</span> score;<br></code></pre></td></tr></table></figure><p>约束：作用于字段上的规则，限制数据<br>![[截屏2024-09-21 10.33.05.png]]<br>自增：auto_increment，可以配合主键</p><p>外键让两张表的数据之间建立连接<br>![[截屏2024-09-21 14.01.29.png]]<br>![[截屏2024-09-21 14.04.27.png]]<br>![[截屏2024-09-21 14.07.07.png]]<br>语法：在创建外键时，后面加上 on update cascade on delete cascade;</p><p>物理外键：使用foreign key定义外键关联另一张表。缺点：影响增删改的效率（需要检查外键关系），仅用于单节点数据库，不适用于分布式、集群场景，容易引发数据库死锁问题。<br>建议使用逻辑外键：在业务层逻辑中，解决外键关联。</p><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><h3 id="多表关系：一对多，多对多，一对一"><a href="#多表关系：一对多，多对多，一对一" class="headerlink" title="多表关系：一对多，多对多，一对一"></a>多表关系：一对多，多对多，一对一</h3><p>一对多：<br>部门和员工，一个部门有很多员工，一个员工只属于一个部门<br>部门表和员工表如果没有关联，如果直接删除部门，不会影响员工表，还是有员工属于被删除的部门，出现数据不完整、不一致。<br>实现：在多的一方建立外键，指向一的主键</p><p>多对多：<br>学生与课程，<br>实现：建立第三方中间表，至少包含两个外键，分别关联两方的主键</p><p>一对一：<br>用户和身份证信息，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率<br>常用于单表拆分，任意一方加入外键，关联另一方的主键，并设置外键为unique</p><h3 id="多表查询：-1"><a href="#多表查询：-1" class="headerlink" title="多表查询："></a>多表查询：</h3><p>笛卡尔积：A集合和B集合的所有组合情况<br><code>select * from A, B where a.id = b.id;</code><br>下面的操作都是在过滤笛卡尔积</p><p>多表查询分类：<br>    连接查询：<br>        内连接：A和B交集<br>        外连接：左/右外连接：查询左/右表的数据和交集的数据<br>        自连接<br>    子查询</p><p>![[截屏2024-09-21 14.31.45.png]]<br><code>select e.name, d.name from emp e, dept d where e.dept_id = d.id;</code><br>注：给表起了别名之后，就不能用原名了</p><p><code>select e.name, d.name from emp e inner join dept d on e.dept_id = d.id;</code></p><p>![[截屏2024-09-21 14.37.40.png]]<br>比如说有一个员工表和一个部门表，其中有一个员工暂时没有分配部门，如果使用内连接的话，这个员工的信息不会显示，这时候可以使用外连接。</p><p>![[截屏2024-09-21 14.42.02.png]]</p><p>自连接必须起表别名，就当成两张表</p><p>![[截屏2024-09-21 14.46.32.png]]<br>union all是直接将两个结果拼起来，不加all的话可以去重。<br>字段列表必须一致</p><h4 id="子查询（嵌套查询）"><a href="#子查询（嵌套查询）" class="headerlink" title="子查询（嵌套查询）"></a>子查询（嵌套查询）</h4><p>sql中嵌套select语句，称为嵌套查询，又称子查询<br>根据内层select语句返回内容可以区分为：标量子查询，列子查询，行子查询，表子查询</p><p>标量子查询，直接用就行，可以用大于号，小于号等等</p><p>![[截屏2024-09-21 14.59.58.png]]</p><p>![[截屏2024-09-21 15.05.53.png]]<br>![[截屏2024-09-21 15.15.11.png]]<br>通常将结果放在from后，</p><h2 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h2><p>![[截屏2024-09-21 20.30.50.png]]<br>开启事务：start transaction; 或begin;<br>提交事务：commit;    （事务里操作都成功后才commit）<br>回滚事务：rollback;   （事务里有操作失败的话就rollback）</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">select</span> @<span class="hljs-title">@autocommit</span><span class="hljs-comment">;    为1是自动提交事物</span><br>set @<span class="hljs-title">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;   为0是手动提交事物</span><br><br><br></code></pre></td></tr></table></figure><p>![[截屏2024-09-21 20.46.19.png]]</p><p>![[截屏2024-09-21 20.50.54.png]]</p><p>![[截屏2024-09-21 20.56.34.png]]</p><p>![[截屏2024-09-21 20.58.29.png]]<br>脏读，read uncommitted<br>例如：事务A先读取了数据，然后事务B修改了数据但没提交，这时A再读取，读取的是B修改后的数据，这个叫read uncommitted</p><p>不可重复读<br>例如：事务A先读取了数据，然后事务B修改了数据，然后提交了，A再读取，发现数据不一样了，也就是在一个事务中，读取了两次数据，结果不一样，这个叫read committed</p><p>幻读：<br>例如：事务A读取一条当前不存在的数据，找不到，然后事务B插入了这条数据，并且提交了，这时事务A想要插入这条数据，不能插入，但是读取还是读不到，</p><p>Serializable 是串行化，事务A在进行的时候，事务B的行为会阻塞（等待事务A完成）</p><p>![[截屏2024-09-21 21.32.24.png]]</p><p>![[截屏2024-09-21 21.35.21.png]]<br>注意index索引在引擎层，表示不同的引擎有不同的处理索引的方式<br>![[截屏2024-09-21 21.38.09.png]]<br>每个数据库表可以有不同的引擎<br>show engine;  查看当前数据库支持的存储引擎</p><p>![[截屏2024-09-21 21.46.00.png]]</p><p>![[截屏2024-09-21 21.50.47.png]]</p><p>![[截屏2024-09-21 21.53.09.png]]</p><p>![[截屏2024-09-21 21.54.24.png]]<br>![[截屏2024-09-21 21.55.00.png]]</p><p>![[截屏2024-09-21 21.57.08.png]]<br>MyISAM被NoSQL数据库MongoDB取代，MEMORY被Redis取代</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>![[截屏2024-09-22 09.07.10.png]]<br>![[截屏2024-09-22 09.11.30.png]]</p><p>![[截屏2024-09-22 09.17.49.png]]</p><p>![[截屏2024-09-22 09.19.58.png]]</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a><br>节点中key的个数大于设置的最大度数后，中间key向上分裂</p><p>![[截屏2024-09-22 09.40.12.png]]<br>数据只存在叶子节点，叶子节点是一个单向链表</p><p>![[截屏2024-09-22 09.44.31.png]]</p><p>![[截屏2024-09-22 09.55.07.png]]</p><p>![[截屏2024-09-22 09.56.54.png]]</p><p>![[截屏2024-09-22 09.57.47.png]]</p><p>![[截屏2024-09-22 09.59.16.png]]</p><p>![[截屏2024-09-22 10.03.37.png]]<br>先在name对应的二级索引里面查找，找到之后再到聚集索引里面查找</p><p>下面的没看懂<br>![[截屏2024-09-22 10.30.20.png]]</p><p>![[截屏2024-09-22 10.32.46.png]]</p><p>![[截屏2024-09-22 10.56.26.png]]</p><p>![[截屏2024-09-22 10.58.56.png]]</p><p><code>show variables like &#39;slow_query_log&#39;;</code> 查看慢查询日志是否为开</p><p>![[截屏2024-09-22 16.32.09.png]]<br>这个是查看是否支持，具体开没开要用：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">select</span> @<span class="hljs-variable">@profiling</span>;<br><span class="hljs-attribute">set</span> profiling = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>![[截屏2024-09-22 16.35.22.png]]</p><p>![[截屏2024-09-22 19.58.39.png]]</p><p>![[截屏2024-09-22 20.11.14.png]]<br>重点关注type，<br>![[截屏2024-09-22 20.14.10.png]]</p><p>![[截屏2024-09-22 20.28.48.png]]</p><p>![[截屏2024-09-22 20.39.03.png]]<br>如果用大于等于就没有这个问题<br>![[截屏2024-09-22 20.42.33.png]]</p><p>![[截屏2024-09-22 20.44.56.png]]<br>有隐式类型转换<br>![[截屏2024-09-22 20.47.03.png]]</p><p>![[截屏2024-09-22 20.50.16.png]]</p><p>![[截屏2024-09-22 20.53.56.png]]<br>感觉找少部分数据会走索引</p><p>![[截屏2024-09-22 21.02.19.png]]</p><p>![[截屏2024-09-22 21.04.59.png]]</p><p>![[截屏2024-09-22 21.09.05.png]]<br>![[截屏2024-09-22 21.12.55.png]]</p><p>![[截屏2024-09-22 21.14.57.png]]</p><p>![[截屏2024-09-22 21.16.38.png]]</p><p>![[截屏2024-09-22 21.22.05.png]]<br>![[截屏2024-09-22 21.26.01.png]]<br>上图查询前5位，lvbu6，找到后回表查询，得到一条行数据。需要检查整个的email是否匹配，</p><p>![[截屏2024-09-22 21.36.56.png]]</p><p>![[截屏2024-09-22 21.38.28.png]]<br>先按phone排序，如果phone一样，再按name排序</p><p>![[截屏2024-09-22 21.48.26.png]]</p><p>![[截屏2024-09-22 22.15.34.png]]</p><p>![[截屏2024-09-22 22.17.28.png]]<br>![[截屏2024-09-22 22.18.07.png]]<br>![[截屏2024-09-22 22.32.22.png]]<br>![[截屏2024-09-22 22.30.58.png]]<br>![[截屏2024-09-22 22.34.19.png]]<br>![[截屏2024-09-22 22.50.47.png]]</p><p>![[截屏2024-09-22 22.54.40.png]]</p><p>![[截屏2024-09-22 23.16.57.png]]</p><p>![[截屏2024-09-22 23.29.42.png]]<br>sql优化没太看懂，主要是针对索引进行优化的</p><p>![[截屏2024-09-23 06.31.16.png]]</p><p>![[截屏2024-09-23 06.36.20.png]]</p><p>with cascaded check option 阻止了添加数据，添加后在视图中看不到的数据</p><p>![[截屏2024-09-23 07.13.23.png]]</p><p>![[截屏2024-09-23 07.20.01.png]]<br>local 也会对它基于的视图进行检查，cascaded会将检查传递给其他视图，而local不会传递，只是检查</p><p>![[截屏2024-09-23 07.22.18.png]]</p><p>![[截屏2024-09-23 07.26.24.png]]</p><p>![[截屏2024-09-23 07.34.08.png]]</p><p>![[截屏2024-09-23 07.36.44.png]]</p><p>![[截屏2024-09-23 07.39.00.png]]</p><p>![[截屏2024-09-23 08.12.39.png]]</p><p>![[截屏2024-09-23 08.16.10.png]]<br>默认是session级别<br>图片中有错误：select @@global.xxx; 注意global与变量名之间是“点”<br>mysql服务重启后会重置系统变量，想要永久改变，需要修改/etc/my.cnf</p><p>![[截屏2024-09-23 08.33.51.png]]<br>自定义的变量不需要声明或初始化，直接用就是null</p><p>![[截屏2024-09-23 08.40.12.png]]</p><p>![[截屏2024-09-23 08.43.44.png]]</p><p>![[截屏2024-09-23 08.47.02.png]]</p><p>![[截屏2024-09-23 09.05.28.png]]</p><p>![[截屏2024-09-23 09.08.33.png]]</p><p>![[截屏2024-09-23 09.13.11.png]]</p><p>![[截屏2024-09-23 09.16.13.png]]</p><p>![[截屏2024-09-23 09.34.50.png]]</p><p>![[截屏2024-09-23 09.44.45.png]]</p><p>![[截屏2024-09-23 09.50.17.png]]</p><p>![[截屏2024-09-23 09.56.18.png]]<br>行级和语句级的区别：例如，如果一个update更新了5行，则要触发5次</p><p>![[截屏2024-09-23 10.00.25.png]]</p><p>![[截屏2024-09-23 10.32.53.png]]</p><p>![[截屏2024-09-23 10.35.01.png]]</p><p>![[截屏2024-09-23 10.36.34.png]]<br>![[截屏2024-09-23 10.41.11.png]]</p><p>![[截屏2024-09-23 10.50.22.png]]</p><p>![[截屏2024-09-23 10.52.28.png]]<br>![[截屏2024-09-23 10.58.42.png]]<br>读锁，只能读不能写，可以阻塞其他客户端的写，其他客户端可以读<br>写锁，当前客户端可以读可以写，其他客户端不能读不能写</p><p>元数据可以简单理解为表结构<br>![[截屏2024-09-23 14.59.03.png]]</p><p>![[截屏2024-09-23 15.14.40.png]]</p><p>意向锁解决的是在innodb引擎中，行锁与表锁的冲突问题</p><p>![[截屏2024-09-23 15.18.54.png]]</p><p>![[截屏2024-09-23 15.19.29.png]]</p><p>![[截屏2024-09-23 15.26.40.png]]</p><p>![[截屏2024-09-23 15.27.57.png]]<br>![[截屏2024-09-23 15.28.14.png]]</p><p>![[截屏2024-09-23 15.30.29.png]]</p><p>![[截屏2024-09-23 15.41.59.png]]</p><p>![[截屏2024-09-23 15.50.44.png]]</p><p>![[截屏2024-09-23 15.56.55.png]]</p><p>![[截屏2024-09-23 15.58.39.png]]</p><p>![[截屏2024-09-23 16.00.58.png]]</p><p>![[截屏2024-09-23 16.03.12.png]]<br>![[截屏2024-09-23 16.04.30.png]]</p><p>![[截屏2024-09-23 16.06.45.png]]</p><p>![[截屏2024-09-23 16.09.41.png]]<br>![[截屏2024-09-23 16.11.41.png]]</p><p>![[截屏2024-09-23 16.13.08.png]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/09/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>ls<br>-a 表示all，列出隐藏文件<br>-l 用列表形式展示<br>-h 与-l搭配，便于展示文件大小</p><p>cd<br>change directory<br>不用参数的话切换到默认目录：/home/luhai</p><p>pwd<br>print work directory</p><p>特殊路径符<br>一个点.  当前目录<br>两个点..  上一级目录<br>波浪~  表示HOME目录<br>回退三级：cd ../../..</p><p>mkdir<br>make directory<br>-p  自动创建不存在的父目录</p><p>touch<br>创建文件<br>cat<br>查看文件<br>more<br>查看文件，支持翻页。空格翻页，q退出</p><p>cp<br>copy，复制<br>-r  复制文件夹，表示递归</p><p>mv<br>move，移动<br>可以用来改名</p><p>rm<br>remove，删除<br>-r  删除文件夹<br>-f  force，强制删除<br>rm命令支持通配符*，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>*：以<span class="hljs-built_in">test</span>开头的<br>*<span class="hljs-built_in">test</span>：以<span class="hljs-built_in">test</span>结尾的<br>*<span class="hljs-built_in">test</span>*：包含<span class="hljs-built_in">test</span>的<br></code></pre></td></tr></table></figure><p>注：rm -rf / 和rm -rf /* 有区别：前一个删除的是根目录，后一个删除的是根目录下的所有文件</p><p>命令其实是二进制可执行程序</p><p>which<br>查看命令所在的位置</p><p>find<br>按文件名查找文件：<br>find 起始路径 -name 文件名（用双引号）<br>按文件大小查找文件：<br>find 起始路径 -size +|-n[kMG]<br>+或-表示大于或小于<br>n是大小数字<br>kMG是单位<br>例如：查找大于1GB的文件：find / -size +1G</p><p>grep<br>从文件中通过关键字过滤文件行<br>-n  显示行号<br>grep 关键字 文件路径<br>文件路径可以作为内容输入端口</p><p>wc<br>文件内容统计<br>-c  byte数量<br>-m  字符数量<br>-l  行数<br>-w 单词数量<br>文件路径可以作为内容输入端口</p><p>管道符 ｜<br>将｜左边的结果作为右边的输入</p><p>echo<br>在命令行输出内容</p><p>反引号<br>包围的内容作为命令执行</p><p>重定向符</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt; <span class="hljs-symbol">:</span>将左边命令的结果，覆盖到右边的文件中<br><span class="hljs-meta prompt_">&gt;&gt;</span> <span class="hljs-symbol">:</span>将左边命令的结果，追加到右边的文件中<br><br></code></pre></td></tr></table></figure><p>tail<br>查看文件尾部<br>-num 例如tail -5 text 查看最后5行<br>-f 持续追踪</p><p>vi/vim<br>三种工作模式：命令，输入，底线命令</p><p>su - root 切换为root用户<br>switch user<br>中间的 - 是可选的，表示在切换用户后加载环境变量<br>注：在我的系统中su - root报错：Authentication failure。应该使用sudo -i，root账户在ubuntu中默认是disabled的，所以没有root密码<br>用 exit 退回上一个用户</p><p>sudo<br>为一条命令授权以root身份运行<br>不是所有用户都能用sudo，需要为普通用户配置sudo认证：在root中输入visudo，在文件最后添加：<br>testUserName ALL=(ALL)  NOPASSWD:ALL</p><p>groupadd 组名 和 groupdel 组名 创建和删除用户组<br>useradd 创建用户，-g 指定用户的组，-d 指定用户的HOME目录<br>userdel 删除用户，-r 删除HOME目录<br>id 用户名，查看用户所属的组<br>usermod -aG 用户组 用户名，修改用户所属的组</p><p>getent<br>查看系统中的用户<br>用户名：密码：用户id：组id：描述信息：HOME目录：执行终端（默认bash）<br>getent group<br>查看系统中的组</p><p>用ll或ls -l 查看文件信息<br>第一部分有十个位，例如drwxr-xr-x<br>第一位：d表示文件夹，-表示文件，l表示软链接<br>第2、3、4位：所属用户权限<br>第5、6、7位：所属用户组权限<br>第8、9、10位：其他用户权限<br>r是读，可以看文件内容，可以看文件夹里面有什么，注意只能看文件夹，不能cd进去<br>w是写，可以修改文件内容，可以在文件夹内创建，删除，改名<br>x是修改execute，可以执行文件，可以cd进文件夹</p><p>chmod<br>修改权限<br>-R 对文件夹内的所有文件执行操作<br>例如：chmod u=rwx,g=rx,o=r test.txt<br>快捷写法：chmod 751 test.txt<br>r是4，w是2，x是1</p><p>chown<br>修改文件所属的用户或用户组，只能由root执行<br>chown 用户：用户组 文件名<br>-R 对文件夹内的所有文件执行操作</p><p>ctrl+c可以停止程序的运行。也可以不管正在输入的命令，重新开始输入<br>ctrl+d退出当前用户的登录，有时可以退出某些程序，例如python<br>history命令，查看历史输入的命令<br>感叹号+少量字符，搜索最近的以少量字符开头的命令并执行<br>ctrl+r 搜索匹配历史命令，用左右键确认<br>ctrl+a 跳到命令开头<br>ctrl+e 跳到命令结尾<br>ctrl+键盘左右键 跳过一个单词<br>ctrl+l或clear 清屏</p><p>centos使用yum安装rpm程序，ubuntu使用apt安装deb程序<br>-y 表示自动确认<br>install，remove，search</p><p>systemctl 控制服务的开启，关闭，状态查看，控制开机是否自启<br>start，stop，status，enable，disable<br>系统内置的服务举例：<br>NetworkManager，主网络服务<br>network，副网络服务<br>firewalld，防火墙<br>sshd，ssh服务</p><p>ln<br>创建软链接，类似Windows中的快捷方式<br>ln -s 被链接的 目的地</p><p>date<br>返回时间<br>%Y 年<br>%y 年份后两位<br>%m 月<br>%d 日<br>%H 小时<br>%M 分钟<br>%S 秒<br>%s 时间戳<br>用法：date +%Y年%m月%d日：输出：2024年09月20日<br>如果格式化字符串里面有空格，用双引号包含从加号之后的部分<br>-d 用于日期计算，支持：year, month, day, hour, minute, second<br>例如：date -d “+1 day +1 month” +%Y-%m-%d</p><p>ifconfig 或者 ip a<br>用来查看ip地址</p><p>hostname<br>查看本机名称</p><p>域名解析<br>输入域名，先在本机的hosts 文件中查找，然后在DNS服务器里查找<br>Linux中的/etc/hosts文件中加入：ip地址 主机名<br>这样就可以通过主机名访问了，就不用输入ip地址了</p><p>虚拟机的ip地址是通过DHCP服务获取的<br>DHCP是动态获取ip地址，</p><p>ping<br>检查服务器是否可联通<br>ping [-c num] ip或主机名<br>-c 检查几次</p><p>wget<br>非交互式的文件下载器<br>-b 后台下载，日志会写入到当前工作目录的wget-log文件中，可以用tail -f wget-log来查看</p><p>curl<br>发送http网络请求，<br>-O 用于下载文件<br>curl cip.cc 可以查看公网ip</p><p>Linux支持65535个端口<br>1-1023:公认端口，系统内置或知名程序，ssh22，http443<br>1024-49151: 注册端口，<br>49152-65535:动态端口，临时使用</p><p>nmap<br>查看端口占用情况<br>nmap 127.0.0.1</p><p>netstat<br>查看指定端口<br>netstat -anp | grep 22</p><p>程序运行后，操作系统会将程序注册为系统中的一个进程<br>ps<br>查看进程信息<br>-e 显示全部进程<br>-f 完全格式化<br>UID：进程所属的用户ID<br>PID：进程ID<br>PPID：进程的父ID（启动此进程的其他进程<br>C：CPU占用率<br>STIME：启动时间<br>TTY：启动此进程的终端序号，如果是？表示非终端启动<br>TIME：占用CPU时间<br>CMD：进程对应的名称或启动路径或启动命令</p><p>kill<br>关闭进程<br>-9 强制关闭</p><p>top<br>查看cpu，内存使用情况，5秒刷新一次<br>第一行，load_average 平均负载 1，5，15分钟。如果为1 表示一个cpu百分百繁忙，如果为4 表示4个cpu百分百繁忙<br>第三行：us用户，sy系统，ni高优先级进程，id空闲，wa IO等待，hi硬件中断，si软件中断，st强制等待<br>第四行mem：物理内存<br>第五行swap：虚拟内存<br>下面的表格中：<br>PR：进程优先级，越小越高<br>NI：负数表示高优先级，正数表示低优先级<br>VIRT：虚拟内存<br>RES：物理内存<br>SHR：共享内存<br>S：进程状态<br>TIME+：进程使用CPU时间总计</p><p>df<br>查看磁盘使用情况<br>-h 更人性化</p><p>iostat<br>查看cpu，磁盘的相关信息<br>-x 显示更多信息<br>其中磁盘部分：tps：设备每秒传输次数</p><p>sar<br>查看网络统计数据<br>sar -n DEV 查看网络接口</p><p>env<br>查看环境变量，是键值对，中间是等号，右侧由冒号分隔<br>系统执行ls这类命令时，在环境变量里面的PATH里面找这个命令对应的二进制程序<br>也就是说：PATH记录了系统执行命令的搜索路径</p><p>$符号用于获取环境变量的值<br>echo $PATH</p><p>设置环境变量：<br>临时：<br>export 名=值<br>永久：<br>当前用户：在<del>/.bashrc文件中<br>所有用户：在</del>/etc/profile文件中<br>通过source 配置文件名 来刷新</p><p>export PATH=$PATH:/程序名</p><p>%% rz和sz<br>上传和下载 %%</p><p>tar归档文件<br>只是简单的封装，没有太多体积的减少<br>gz压缩文件<br>使用gzip压缩算法进行压缩</p><p>tar<br>-c 创建压缩文件<br>-v 显示进度<br>-x 解压模式<br>-f 要压缩或解压的文件，-f必须位于最后一个参数<br>-z gzip模式，一般位于第一个参数位置<br>-C 解压目的地</p><p>压缩时常用组合：<br>tar -cvf test.tar 1.txt 2.txt 3.txt<br>tar -zcvf text.tar.gz 1.txt 2.txt 3.txt</p><p>解压时常用组合<br>tar -xvf name.tar<br>tar -xvf name.tar -C /…<br>tar -zxvf name.tar.gz</p><p>zip<br>压缩文件<br>-r 被压缩文件包含文件夹时<br>unzip<br>解压文件<br>-d 指定目的地</p><p>scp<br>文件传输<br>SSH文件传输:</p><ul><li>在Linux电脑上确保已安装并运行SSH服务器。</li><li>在Mac上打开终端,使用scp命令传输文件: <code>scp /path/to/local/file username@linux_ip_address:/path/to/destination</code></li></ul><p>git<br>sudo apt install git</p><ol><li>git config –global user.name “==Your Name==”</li><li>git config –global user.email “<a href="mailto:youremail@domain.com">youremail@domain.com</a>“</li><li>git config –list<br>生成ssh密钥<br>ssh-keygen -t ed25519 -C “您的GitHub邮箱”<br>添加SSH密钥到SSH代理:<br>eval “$(ssh-agent -s)”<br>ssh-add ~/.ssh/id_ed25519<br>复制公钥：<br>cat ~/.ssh/id_ed25519.pub<br>在github设置中添加ssh key<br>测试链接：<br>ssh -T <a href="mailto:git@github.com">git@github.com</a></li></ol><p>通过appimage安装软件<br>需要安装FUSE，然后需要下面的命令<br>sudo add-apt-repository universe</p><ol><li>在 Ubuntu 中，软件仓库被分为多个部分，其中包括：<ul><li><strong>main</strong>：包含 Ubuntu 开发者完全支持的软件。</li><li><strong>universe</strong>：包含由社区维护的开源软件，虽然不如 main 中的软件那么受支持，但也是官方认可的开源软件库。<br>因此，<code>add-apt-repository universe</code> 命令的作用是向你的系统中添加 “universe” 仓库，使得你能够从该仓库中安装社区维护的软件包。<br>在添加此仓库后，系统将有更多的可用软件可以通过 <code>apt</code> 命令进行安装。</li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>综述：基于LLM的自主Agent</title>
    <link href="/2024/06/14/%E7%BB%BC%E8%BF%B0%EF%BC%9A%E5%9F%BA%E4%BA%8ELLM%E7%9A%84%E8%87%AA%E4%B8%BBAgent/"/>
    <url>/2024/06/14/%E7%BB%BC%E8%BF%B0%EF%BC%9A%E5%9F%BA%E4%BA%8ELLM%E7%9A%84%E8%87%AA%E4%B8%BBAgent/</url>
    
    <content type="html"><![CDATA[<h1 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h1 id="基于LLM的自主Agent的结构"><a href="#基于LLM的自主Agent的结构" class="headerlink" title="基于LLM的自主Agent的结构"></a>基于LLM的自主Agent的<font color="#ff0000">结构</font></h1><h1 id="基于LLM的自主Agent的应用"><a href="#基于LLM的自主Agent的应用" class="headerlink" title="基于LLM的自主Agent的应用"></a>基于LLM的自主Agent的<font color="#ff0000">应用</font></h1><h1 id="基于LLM的自主Agent的评估"><a href="#基于LLM的自主Agent的评估" class="headerlink" title="基于LLM的自主Agent的评估"></a>基于LLM的自主Agent的<font color="#ff0000">评估</font></h1>]]></content>
    
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>Paper</tag>
      
      <tag>Agent</tag>
      
      <tag>Survey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/06/13/A%20survey%20on%20large%20language%20model%20based%20autonomous%20agents/"/>
    <url>/2024/06/13/A%20survey%20on%20large%20language%20model%20based%20autonomous%20agents/</url>
    
    <content type="html"><![CDATA[<h1 id="Paper-structure"><a href="#Paper-structure" class="headerlink" title="Paper structure"></a>Paper structure</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="LLM-based-autonomous-agent-construction"><a href="#LLM-based-autonomous-agent-construction" class="headerlink" title="LLM-based autonomous agent construction"></a>LLM-based autonomous agent <font color="#ff0000">construction</font></h2><h2 id="LLM-based-autonomous-agent-application"><a href="#LLM-based-autonomous-agent-application" class="headerlink" title="LLM-based autonomous agent application"></a>LLM-based autonomous agent <font color="#ff0000">application</font></h2><h2 id="LLM-based-autonomous-agent-evaluation"><a href="#LLM-based-autonomous-agent-evaluation" class="headerlink" title="LLM-based autonomous agent evaluation"></a>LLM-based autonomous agent <font color="#ff0000">evaluation</font></h2><h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/05/31/Generative%20Agents%EF%BC%9AInteractive%20Simulacra%20of%20Human%20Behavior/"/>
    <url>/2024/05/31/Generative%20Agents%EF%BC%9AInteractive%20Simulacra%20of%20Human%20Behavior/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/joonspk-research/generative_agents">Github</a><a href="https://reverie.herokuapp.com/arXiv_Demo/">论文附带的模拟的预先计算重播</a></p><h2 id="Medium文章"><a href="#Medium文章" class="headerlink" title="Medium文章"></a><a href="https://rikiphukon.medium.com/stanford-smallville-is-officially-open-source-9882e3fbc981">Medium文章</a></h2><p>在这个游戏中，25 个 ChatGPT AI 代理用自然语言相互交流，规划自己的日程，建立关系，甚至进行自我反思。他们讨论现实世界的话题，例如即将到来的选举，其中一些甚至举办了情人节派对！<br>值得注意的是，这些代理的互动与真人非常相似。他们会询问对方的意见，发送派对邀请，并协调在正确的时间出现。这些代理是知情的公民，会反思自己的个性和兴趣。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/05/30/awesome-chatgpt-prompts/"/>
    <url>/2024/05/30/awesome-chatgpt-prompts/</url>
    
    <content type="html"><![CDATA[<p><strong>Act as a Prompt Generator</strong></p><p>Contributed by: <a href="https://github.com/iuzn">@iuzn</a></p><blockquote><p>I want you to act as a prompt generator. Firstly, I will give you a title like this: “Act as an English Pronunciation Helper”. Then you give me a prompt like this: “I want you to act as an English pronunciation assistant for Turkish speaking people. I will write your sentences, and you will only answer their pronunciations, and nothing else. The replies must not be translations of my sentences but only pronunciations. Pronunciations should use Turkish Latin letters for phonetics. Do not write explanations on replies. My first sentence is “how the weather is in Istanbul?”.” (You should adapt the sample prompt according to the title I gave. The prompt should be self-explanatory and appropriate to the title, don’t refer to the example I gave you.). My first title is “Act as a Code Review Helper” (Give me prompt only)</p></blockquote><p><strong>Act as a Prompt Enhancer</strong></p><p>Contributed by: <a href="https://github.com/iuzn">@iuzn</a> Generated by ChatGPT</p><blockquote><p>Act as a Prompt Enhancer AI that takes user-input prompts and transforms them into more engaging, detailed, and thought-provoking questions. Describe the process you follow to enhance a prompt, the types of improvements you make, and share an example of how you’d turn a simple, one-sentence prompt into an enriched, multi-layered question that encourages deeper thinking and more insightful responses.</p></blockquote><p><strong>Act as a Midjourney Prompt Generator</strong></p><p>Contributed by: <a href="https://github.com/iuzn">@iuzn</a> Generated by ChatGPT</p><blockquote><p>I want you to act as a prompt generator for Midjourney’s artificial intelligence program. Your job is to provide detailed and creative descriptions that will inspire unique and interesting images from the AI. Keep in mind that the AI is capable of understanding a wide range of language and can interpret abstract concepts, so feel free to be as imaginative and descriptive as possible. For example, you could describe a scene from a futuristic city, or a surreal landscape filled with strange creatures. The more detailed and imaginative your description, the more interesting the resulting image will be. Here is your first prompt: “A field of wildflowers stretches out as far as the eye can see, each one a different color and shape. In the distance, a massive tree towers over the landscape, its branches reaching up to the sky like tentacles.”</p></blockquote><p><strong>Act as an Academician</strong></p><p>Contributed by: <a href="https://github.com/devisasari">@devisasari</a></p><blockquote><p>I want you to act as an academician. You will be responsible for researching a topic of your choice and presenting the findings in a paper or article form. Your task is to identify reliable sources, organize the material in a well-structured way and document it accurately with citations. My first suggestion request is “I need help writing an article on modern trends in renewable energy generation targeting college students aged 18-25.”</p></blockquote><p><strong>Act as a Social Media Influencer</strong></p><p>Contributed by: <a href="https://github.com/devisasari">@devisasari</a></p><blockquote><p>I want you to act as a social media influencer. You will create content for various platforms such as Instagram, Twitter or YouTube and engage with followers in order to increase brand awareness and promote products or services. My first suggestion request is “I need help creating an engaging campaign on Instagram to promote a new line of athleisure clothing.”</p></blockquote><p><strong>Act as a ChatGPT prompt generator</strong></p><p>Contributed by <a href="https://github.com/y1j2x34">@y1j2x34</a></p><blockquote><p>I want you to act as a ChatGPT prompt generator, I will send a topic, you have to generate a ChatGPT prompt based on the content of the topic, the prompt should start with “I want you to act as “, and guess what I might do, and expand the prompt accordingly Describe the content to make it useful.</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
